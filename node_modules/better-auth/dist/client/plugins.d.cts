import * as nanostores from 'nanostores';
import { AccessControl, StatementsPrimitive, Role } from '../plugins/access.cjs';
import * as _better_fetch_fetch from '@better-fetch/fetch';
import { BetterFetchOption } from '@better-fetch/fetch';
import { o as organization, q as Organization, M as Member, I as Invitation, u as username, m as magicLink, d as phoneNumber, f as anonymous, i as admin, j as genericOAuth, k as jwt, l as multiSession, n as emailOTP } from '../index-Q5mYsB6F.cjs';
export { g as getPasskeyActions, c as passkeyClient, a as twoFactorClient } from '../index-Q5mYsB6F.cjs';
import { P as Prettify } from '../helper-DrEEwdyQ.cjs';
import { O as FieldAttribute, B as BetterAuthOptions, j as BetterAuthPlugin } from '../auth-DvJrys4P.cjs';
import { Store } from '../types.cjs';
import 'zod';
import 'better-call';
import '@simplewebauthn/types';
import '../index-BNVrpPYq.cjs';
import 'jose';
import 'kysely';
import 'better-sqlite3';

interface OrganizationClientOptions {
    ac: AccessControl;
    roles: {
        [key in string]: Role;
    };
}
declare const organizationClient: <O extends OrganizationClientOptions>(options?: O) => {
    id: "organization";
    $InferServerPlugin: ReturnType<typeof organization<{
        ac: O["ac"] extends AccessControl ? O["ac"] : AccessControl<{
            readonly organization: readonly ["update", "delete"];
            readonly member: readonly ["create", "update", "delete"];
            readonly invitation: readonly ["create", "cancel"];
        }>;
        roles: O["roles"] extends Record<string, Role> ? O["roles"] : {
            admin: Role;
            member: Role;
            owner: Role;
        };
    }>>;
    getActions: ($fetch: _better_fetch_fetch.BetterFetch) => {
        $Infer: {
            ActiveOrganization: Prettify<Organization & {
                members: Prettify<Member & {
                    user: {
                        id: string;
                        name: string;
                        email: string;
                        image?: string | null;
                    };
                }>[];
                invitations: Invitation[];
            }>;
            Organization: Organization;
            Invitation: Invitation;
            Member: Member;
        };
        organization: {
            checkRolePermission: <R extends O extends {
                roles: any;
            } ? keyof O["roles"] : "admin" | "member" | "owner">(data: {
                role: R;
                permission: Partial<{ [key in keyof (O["ac"] extends AccessControl<infer S extends StatementsPrimitive> ? S extends Record<string, any[]> ? S & {
                    readonly organization: readonly ["update", "delete"];
                    readonly member: readonly ["create", "update", "delete"];
                    readonly invitation: readonly ["create", "cancel"];
                } : {
                    readonly organization: readonly ["update", "delete"];
                    readonly member: readonly ["create", "update", "delete"];
                    readonly invitation: readonly ["create", "cancel"];
                } : {
                    readonly organization: readonly ["update", "delete"];
                    readonly member: readonly ["create", "update", "delete"];
                    readonly invitation: readonly ["create", "cancel"];
                })]: (O["ac"] extends AccessControl<infer S extends StatementsPrimitive> ? S extends Record<string, any[]> ? S & {
                    readonly organization: readonly ["update", "delete"];
                    readonly member: readonly ["create", "update", "delete"];
                    readonly invitation: readonly ["create", "cancel"];
                } : {
                    readonly organization: readonly ["update", "delete"];
                    readonly member: readonly ["create", "update", "delete"];
                    readonly invitation: readonly ["create", "cancel"];
                } : {
                    readonly organization: readonly ["update", "delete"];
                    readonly member: readonly ["create", "update", "delete"];
                    readonly invitation: readonly ["create", "cancel"];
                })[key][number][]; }>;
            }) => boolean;
        };
    };
    getAtoms: ($fetch: _better_fetch_fetch.BetterFetch) => {
        $listOrg: nanostores.PreinitializedWritableAtom<boolean>;
        $activeOrgSignal: nanostores.PreinitializedWritableAtom<boolean>;
        $activeMemberSignal: nanostores.PreinitializedWritableAtom<boolean>;
        activeOrganization: nanostores.PreinitializedWritableAtom<{
            data: Prettify<{
                name: string;
                id: string;
                createdAt: Date;
                slug: string;
                metadata?: any;
                logo?: string | null | undefined;
            } & {
                members: (Member & {
                    user: {
                        id: string;
                        name: string;
                        email: string;
                        image: string | undefined;
                    };
                })[];
                invitations: Invitation[];
            }> | null;
            error: null | _better_fetch_fetch.BetterFetchError;
            isPending: boolean;
            isRefetching: boolean;
        }>;
        listOrganizations: nanostores.PreinitializedWritableAtom<{
            data: {
                name: string;
                id: string;
                createdAt: Date;
                slug: string;
                metadata?: any;
                logo?: string | null | undefined;
            }[] | null;
            error: null | _better_fetch_fetch.BetterFetchError;
            isPending: boolean;
            isRefetching: boolean;
        }>;
        activeMember: nanostores.PreinitializedWritableAtom<{
            data: {
                id: string;
                createdAt: Date;
                userId: string;
                role: string;
                organizationId: string;
            } | null;
            error: null | _better_fetch_fetch.BetterFetchError;
            isPending: boolean;
            isRefetching: boolean;
        }>;
    };
    atomListeners: ({
        matcher(path: string): path is "/organization/create" | "/organization/delete";
        signal: "$listOrg";
    } | {
        matcher(path: string): boolean;
        signal: "$activeOrgSignal";
    } | {
        matcher(path: string): boolean;
        signal: "$activeMemberSignal";
    })[];
};

declare const usernameClient: () => {
    id: "username";
    $InferServerPlugin: ReturnType<typeof username>;
};

declare const magicLinkClient: () => {
    id: "magic-link";
    $InferServerPlugin: ReturnType<typeof magicLink>;
};

declare const phoneNumberClient: () => {
    id: "phoneNumber";
    $InferServerPlugin: ReturnType<typeof phoneNumber>;
    atomListeners: {
        matcher(path: string): path is "/phone-number/verify" | "/phone-number/update";
        signal: "$sessionSignal";
    }[];
};

declare const anonymousClient: () => {
    id: "anonymous";
    $InferServerPlugin: ReturnType<typeof anonymous>;
    pathMethods: {
        "/sign-in/anonymous": "POST";
    };
};

declare const inferAdditionalFields: <T, S extends {
    user?: {
        [key: string]: FieldAttribute;
    };
    session?: {
        [key: string]: FieldAttribute;
    };
} = {}>(schema?: S) => {
    id: "additional-fields-client";
    $InferServerPlugin: ((T extends BetterAuthOptions ? T : T extends {
        options: BetterAuthOptions;
    } ? T["options"] : never) extends never ? S extends {
        user?: {
            [key: string]: FieldAttribute;
        };
        session?: {
            [key: string]: FieldAttribute;
        };
    } ? {
        id: "additional-fields-client";
        schema: {
            user: {
                fields: S["user"] extends object ? S["user"] : {};
            };
            session: {
                fields: S["session"] extends object ? S["session"] : {};
            };
        };
    } : never : (T extends BetterAuthOptions ? T : T extends {
        options: BetterAuthOptions;
    } ? T["options"] : never) extends BetterAuthOptions ? {
        id: "additional-fields";
        schema: {
            user: {
                fields: (T extends BetterAuthOptions ? T : T extends {
                    options: BetterAuthOptions;
                } ? T["options"] : never)["user"] extends {
                    additionalFields: infer U;
                } ? U : {};
            };
            session: {
                fields: (T extends BetterAuthOptions ? T : T extends {
                    options: BetterAuthOptions;
                } ? T["options"] : never)["session"] extends {
                    additionalFields: infer U;
                } ? U : {};
            };
        };
    } : never) extends BetterAuthPlugin ? (T extends BetterAuthOptions ? T : T extends {
        options: BetterAuthOptions;
    } ? T["options"] : never) extends never ? S extends {
        user?: {
            [key: string]: FieldAttribute;
        };
        session?: {
            [key: string]: FieldAttribute;
        };
    } ? {
        id: "additional-fields-client";
        schema: {
            user: {
                fields: S["user"] extends object ? S["user"] : {};
            };
            session: {
                fields: S["session"] extends object ? S["session"] : {};
            };
        };
    } : never : (T extends BetterAuthOptions ? T : T extends {
        options: BetterAuthOptions;
    } ? T["options"] : never) extends BetterAuthOptions ? {
        id: "additional-fields";
        schema: {
            user: {
                fields: (T extends BetterAuthOptions ? T : T extends {
                    options: BetterAuthOptions;
                } ? T["options"] : never)["user"] extends {
                    additionalFields: infer U;
                } ? U : {};
            };
            session: {
                fields: (T extends BetterAuthOptions ? T : T extends {
                    options: BetterAuthOptions;
                } ? T["options"] : never)["session"] extends {
                    additionalFields: infer U;
                } ? U : {};
            };
        };
    } : never : undefined;
};

declare const adminClient: () => {
    id: "better-auth-client";
    $InferServerPlugin: ReturnType<typeof admin>;
    pathMethods: {
        "/admin/list-users": "GET";
    };
};

declare const genericOAuthClient: () => {
    id: "generic-oauth-client";
    $InferServerPlugin: ReturnType<typeof genericOAuth>;
};

declare const jwtClient: () => {
    id: "better-auth-client";
    $InferServerPlugin: ReturnType<typeof jwt>;
};

declare const multiSessionClient: () => {
    id: "multi-session";
    $InferServerPlugin: ReturnType<typeof multiSession>;
    atomListeners: {
        matcher(path: string): path is "/multi-session/set-active";
        signal: "$sessionSignal";
    }[];
};

declare const emailOTPClient: () => {
    id: "email-otp";
    $InferServerPlugin: ReturnType<typeof emailOTP>;
};

declare global {
    interface Window {
        google?: {
            accounts: {
                id: {
                    initialize: (config: any) => void;
                    prompt: () => void;
                };
            };
        };
        googleScriptInitialized?: boolean;
    }
}
interface GoogleOneTapOptions {
    /**
     * Google client ID
     */
    clientId: string;
    /**
     * Auto select the account if the user is already signed in
     */
    autoSelect?: boolean;
    /**
     * Cancel the flow when the user taps outside the prompt
     */
    cancelOnTapOutside?: boolean;
    /**
     * Context of the Google One Tap flow
     */
    context?: "signin" | "signup" | "use";
}
interface GoogleOneTapActionOptions extends Omit<GoogleOneTapOptions, "clientId"> {
    fetchOptions?: BetterFetchOption;
    callbackURL?: string;
}
declare const oneTapClient: (options: GoogleOneTapOptions) => {
    id: "one-tap";
    getActions: ($fetch: _better_fetch_fetch.BetterFetch, _: Store) => {
        oneTap: (opts?: GoogleOneTapActionOptions, fetchOptions?: BetterFetchOption) => Promise<void>;
    };
    getAtoms($fetch: _better_fetch_fetch.BetterFetch): {};
};

export { adminClient, anonymousClient, emailOTPClient, genericOAuthClient, inferAdditionalFields, jwtClient, magicLinkClient, multiSessionClient, oneTapClient, organizationClient, phoneNumberClient, usernameClient };
