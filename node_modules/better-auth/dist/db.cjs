"use strict";var B=Object.defineProperty;var Z=Object.getOwnPropertyDescriptor;var G=Object.getOwnPropertyNames;var Q=Object.prototype.hasOwnProperty;var X=(e,n)=>{for(var d in n)B(e,d,{get:n[d],enumerable:!0})},Y=(e,n,d,u)=>{if(n&&typeof n=="object"||typeof n=="function")for(let p of G(n))!Q.call(e,p)&&p!==d&&B(e,p,{get:()=>n[p],enumerable:!(u=Z(n,p))||u.enumerable});return e};var ee=e=>Y(B({},"__esModule",{value:!0}),e);var be={};X(be,{convertFromDB:()=>ue,convertToDB:()=>le,createFieldAttribute:()=>se,createInternalAdapter:()=>ie,getAdapter:()=>de,getAuthTables:()=>k,getMigrations:()=>Ae,getSchema:()=>j,getWithHooks:()=>P,matchType:()=>z,toZodSchema:()=>ae});module.exports=ee(be);var V=(e,n="ms")=>new Date(Date.now()+(n==="sec"?e*1e3:e));var x=require("zod"),Te=x.z.object({id:x.z.string(),providerId:x.z.string(),accountId:x.z.string(),userId:x.z.string(),accessToken:x.z.string().nullish(),refreshToken:x.z.string().nullish(),idToken:x.z.string().nullish(),expiresAt:x.z.date().nullish(),password:x.z.string().nullish()}),ve=x.z.object({id:x.z.string(),email:x.z.string().transform(e=>e.toLowerCase()),emailVerified:x.z.boolean().default(!1),name:x.z.string(),image:x.z.string().nullish(),createdAt:x.z.date().default(new Date),updatedAt:x.z.date().default(new Date)}),Fe=x.z.object({id:x.z.string(),userId:x.z.string(),expiresAt:x.z.date(),ipAddress:x.z.string().nullish(),userAgent:x.z.string().nullish()}),Oe=x.z.object({id:x.z.string(),value:x.z.string(),createdAt:x.z.date(),expiresAt:x.z.date(),identifier:x.z.string()});function K(e,n){let d=n.fields,u={};for(let p in e){let g=d[p];if(!g){u[p]=e[p];continue}g.returned!==!1&&(u[p]=e[p])}return u}function E(e,n){let d={...n==="user"?e.user?.additionalFields:{},...n==="session"?e.session?.additionalFields:{}};for(let u of e.plugins||[])u.schema&&u.schema[n]&&(d={...d,...u.schema[n].fields});return d}function L(e,n){let d=E(e,"user");return K(n,{fields:d})}function q(e,n){let d=E(e,"session");return K(n,{fields:d})}var C=require("nanoid"),T=e=>(0,C.nanoid)(e);function P(e,n){let d=n.hooks;async function u(m,A,r){let t=m;for(let o of d||[]){let a=o[A]?.create?.before;if(a){let s=await a(m);if(s===!1)return null;typeof s=="object"&&"data"in s&&(t=s.data)}}let i=r?await r.fn(t):null,c=!r||r.executeMainFn?await e.create({model:A,data:t}):i;for(let o of d||[]){let a=o[A]?.create?.after;a&&await a(c)}return c}async function p(m,A,r,t){let i=m;for(let a of d||[]){let s=a[r]?.update?.before;if(s){let l=await s(m);if(l===!1)return null;i=typeof l=="object"?l.data:l}}let c=t?await t.fn(i):null,o=!t||t.executeMainFn?await e.update({model:r,update:i,where:A}):c;for(let a of d||[]){let s=a[r]?.update?.after;s&&await s(o)}return o}async function g(m,A,r,t){let i=m;for(let a of d||[]){let s=a[r]?.update?.before;if(s){let l=await s(m);if(l===!1)return null;i=typeof l=="object"?l.data:l}}let c=t?await t.fn(i):null,o=!t||t.executeMainFn?await e.updateMany({model:r,update:i,where:A}):c;for(let a of d||[]){let s=a[r]?.update?.after;s&&await s(o)}return o}return{createWithHooks:u,updateWithHooks:p,updateManyWithHooks:g}}var S=Object.create(null),O=e=>globalThis.process?.env||globalThis.Deno?.env.toObject()||globalThis.__env__||(e?S:globalThis),te=new Proxy(S,{get(e,n){return O()[n]??S[n]},has(e,n){let d=O();return n in d||n in S},set(e,n,d){let u=O(!0);return u[n]=d,!0},deleteProperty(e,n){if(!n)return!1;let d=O(!0);return delete d[n],!0},ownKeys(){let e=O(!0);return Object.keys(e)}});function re(e){return e?e!=="false":!1}var ne=typeof process<"u"&&process.env&&process.env.NODE_ENV||"";var H=ne==="test"||re(te.TEST);function W(e,n){if(n.advanced?.ipAddress?.disableIpTracking)return null;let d="127.0.0.1";if(H)return d;let p=n.advanced?.ipAddress?.ipAddressHeaders||["x-client-ip","x-forwarded-for","cf-connecting-ip","fastly-client-ip","x-real-ip","x-cluster-client-ip","x-forwarded","forwarded-for","forwarded"],g=e instanceof Request?e.headers:e;for(let m of p){let A=g.get(m);if(typeof A=="string"){let r=A.split(",")[0].trim();if(r)return r}}return null}function D(e){try{return JSON.parse(e)}catch{return null}}var ie=(e,n)=>{let d=n.options,u=d.secondaryStorage,p=d.session?.expiresIn||60*60*24*7,{createWithHooks:g,updateWithHooks:m,updateManyWithHooks:A}=P(e,n);return{createOAuthUser:async(r,t)=>{try{let i=await g({id:T(),createdAt:new Date,updatedAt:new Date,...r},"user"),c=await g({id:T(),...t,userId:i.id||r.id},"account");return{user:i,account:c}}catch(i){return console.log(i),null}},createUser:async r=>await g({id:T(),createdAt:new Date,updatedAt:new Date,emailVerified:!1,...r},"user"),createAccount:async r=>await g({id:T(),createdAt:new Date,updatedAt:new Date,...r},"account"),listSessions:async r=>{if(u){let i=await u.get(`active-sessions-${r}`);if(!i)return[];let c=D(i)||[],o=Date.now(),a=c.filter(l=>l.expiresAt>o),s=[];for(let l of a){let y=await u.get(l.id);if(y){let f=JSON.parse(y),h=q(n.options,{...f.session,expiresAt:new Date(f.session.expiresAt)});s.push(h)}}return s}return await e.findMany({model:"session",where:[{field:"userId",value:r}]})},listUsers:async(r,t,i,c)=>await e.findMany({model:"user",limit:r,offset:t,sortBy:i,where:c}),deleteUser:async r=>{await e.deleteMany({model:"session",where:[{field:"userId",value:r}]}),await e.deleteMany({model:"account",where:[{field:"userId",value:r}]}),await e.delete({model:"user",where:[{field:"id",value:r}]})},createSession:async(r,t,i,c)=>{let o=t instanceof Request?t.headers:t,a={expiresAt:i?V(60*60*24,"sec"):V(p,"sec"),ipAddress:t&&W(t,n.options)||"",userAgent:o?.get("user-agent")||"",...c,id:T(32),userId:r};return await g(a,"session",u?{fn:async l=>{let y=await e.findOne({model:"user",where:[{field:"id",value:r}]});u.set(l.id,JSON.stringify({session:l,user:y}),p);let f=await u.get(`active-sessions-${r}`),h=[],b=Date.now();return f&&(h=D(f)||[],h=h.filter(F=>F.expiresAt>b)),h.push({id:l.id,expiresAt:b+p*1e3}),await u.set(`active-sessions-${r}`,JSON.stringify(h),p),l},executeMainFn:d.session?.storeSessionInDatabase}:void 0)},findSession:async r=>{if(u){let o=await u.get(r);if(o){let a=JSON.parse(o),s=q(n.options,{...a.session,expiresAt:new Date(a.session.expiresAt)}),l=L(n.options,{...a.user,createdAt:new Date(a.user.createdAt),updatedAt:new Date(a.user.updatedAt)});return{session:s,user:l}}}let t=await e.findOne({model:"session",where:[{value:r,field:"id"}]});if(!t)return null;let i=await e.findOne({model:"user",where:[{value:t.userId,field:"id"}]});if(!i)return null;let c=L(n.options,i);return{session:q(n.options,t),user:c}},findSessions:async r=>{if(u){let o=[];for(let a of r){let s=await u.get(a);if(s){let l=JSON.parse(s),y={session:{...l.session,expiresAt:new Date(l.session.expiresAt)},user:{...l.user,createdAt:new Date(l.user.createdAt),updatedAt:new Date(l.user.updatedAt)}};o.push(y)}}return o}let t=await e.findMany({model:"session",where:[{field:"id",value:r,operator:"in"}]}),i=t.map(o=>o.userId);if(!i.length)return[];let c=await e.findMany({model:"user",where:[{field:"id",value:i,operator:"in"}]});return t.map(o=>{let a=c.find(s=>s.id===o.userId);return a?{session:o,user:a}:null})},updateSession:async(r,t)=>await m(t,[{field:"id",value:r}],"session",u?{async fn(c){let o=await u.get(r),a=null;if(o){let s=JSON.parse(o);a={...s.session,...c},await u.set(r,JSON.stringify({session:a,user:s.user}),s.session.expiresAt?Math.floor((s.session.expiresAt.getTime()-Date.now())/1e3):p)}else return null},executeMainFn:d.session?.storeSessionInDatabase}:void 0),deleteSession:async r=>{if(u){await u.delete(r),d.session?.storeSessionInDatabase&&await e.delete({model:"session",where:[{field:"id",value:r}]});return}await e.delete({model:"session",where:[{field:"id",value:r}]})},deleteSessions:async r=>{if(u){if(typeof r=="string"){let t=await u.get(`active-sessions-${r}`),i=t?D(t):[];if(!i)return;for(let c of i)await u.delete(c.id)}else for(let t of r)await u.get(t)&&await u.delete(t);d.session?.storeSessionInDatabase&&await e.deleteMany({model:"session",where:[{field:Array.isArray(r)?"id":"userId",value:r,operator:Array.isArray(r)?"in":void 0}]});return}await e.deleteMany({model:"session",where:[{field:Array.isArray(r)?"id":"userId",value:r,operator:Array.isArray(r)?"in":void 0}]})},findUserByEmail:async(r,t)=>{let i=await e.findOne({model:"user",where:[{value:r.toLowerCase(),field:"email"}]});if(!i)return null;if(t?.includeAccounts){let c=await e.findMany({model:"account",where:[{value:i.id,field:"userId"}]});return{user:i,accounts:c}}return{user:i,accounts:[]}},findUserById:async r=>await e.findOne({model:"user",where:[{field:"id",value:r}]}),linkAccount:async r=>await g({id:T(),...r},"account"),updateUser:async(r,t)=>await m(t,[{field:"id",value:r}],"user"),updateUserByEmail:async(r,t)=>await m(t,[{field:"email",value:r}],"user"),updatePassword:async(r,t)=>{await A({password:t},[{field:"userId",value:r},{field:"providerId",value:"credential"}],"account")},findAccounts:async r=>await e.findMany({model:"account",where:[{field:"userId",value:r}]}),findAccount:async r=>await e.findOne({model:"account",where:[{field:"accountId",value:r}]}),findAccountByUserId:async r=>await e.findMany({model:"account",where:[{field:"userId",value:r}]}),updateAccount:async(r,t)=>await m(t,[{field:"id",value:r}],"account"),createVerificationValue:async r=>await g({id:T(),createdAt:new Date,...r},"verification"),findVerificationValue:async r=>(await e.findMany({model:"verification",where:[{field:"identifier",value:r}],sortBy:{field:"createdAt",direction:"desc"},limit:10}))[0],deleteVerificationValue:async r=>{await e.delete({model:"verification",where:[{field:"id",value:r}]})},deleteVerificationByIdentifier:async r=>{await e.delete({model:"verification",where:[{field:"identifier",value:r}]})},updateVerificationValue:async(r,t)=>await m(t,[{field:"id",value:r}],"verification")}};var se=(e,n)=>({type:e,...n});var k=e=>{let n=e.plugins?.reduce((r,t)=>{let i=t.schema;if(!i)return r;for(let[c,o]of Object.entries(i))r[c]={fields:{...r[c]?.fields,...o.fields},modelName:o.modelName||c};return r},{}),d=e.rateLimit?.storage==="database",u={rateLimit:{modelName:e.rateLimit?.modelName||"rateLimit",fields:{key:{type:"string",fieldName:e.rateLimit?.fields?.key||"key"},count:{type:"number",fieldName:e.rateLimit?.fields?.count||"count"},lastRequest:{type:"number",fieldName:e.rateLimit?.fields?.lastRequest||"lastRequest"}}}},{user:p,session:g,account:m,...A}=n||{};return{user:{modelName:e.user?.modelName||"user",fields:{name:{type:"string",required:!0,fieldName:e.user?.fields?.name||"name"},email:{type:"string",unique:!0,required:!0,fieldName:e.user?.fields?.email||"email"},emailVerified:{type:"boolean",defaultValue:()=>!1,required:!0,fieldName:e.user?.fields?.emailVerified||"emailVerified"},image:{type:"string",required:!1,fieldName:e.user?.fields?.image||"image"},createdAt:{type:"date",defaultValue:()=>new Date,required:!0,fieldName:e.user?.fields?.createdAt||"createdAt"},updatedAt:{type:"date",defaultValue:()=>new Date,required:!0,fieldName:e.user?.fields?.updatedAt||"updatedAt"},...p?.fields,...e.user?.additionalFields},order:1},session:{modelName:e.session?.modelName||"session",fields:{expiresAt:{type:"date",required:!0,fieldName:e.session?.fields?.expiresAt||"expiresAt"},ipAddress:{type:"string",required:!1,fieldName:e.session?.fields?.ipAddress||"ipAddress"},userAgent:{type:"string",required:!1,fieldName:e.session?.fields?.userAgent||"userAgent"},userId:{type:"string",fieldName:e.session?.fields?.userId||"userId",references:{model:e.user?.modelName||"user",field:"id",onDelete:"cascade"},required:!0},...g?.fields,...e.session?.additionalFields},order:2},account:{modelName:e.account?.modelName||"account",fields:{accountId:{type:"string",required:!0,fieldName:e.account?.fields?.accountId||"accountId"},providerId:{type:"string",required:!0,fieldName:e.account?.fields?.providerId||"providerId"},userId:{type:"string",references:{model:e.user?.modelName||"user",field:"id",onDelete:"cascade"},required:!0,fieldName:e.account?.fields?.userId||"userId"},accessToken:{type:"string",required:!1,fieldName:e.account?.fields?.accessToken||"accessToken"},refreshToken:{type:"string",required:!1,fieldName:e.account?.fields?.refreshToken||"refreshToken"},idToken:{type:"string",required:!1,fieldName:e.account?.fields?.idToken||"idToken"},expiresAt:{type:"date",required:!1,fieldName:e.account?.fields?.expiresAt||"expiresAt"},password:{type:"string",required:!1,fieldName:e.account?.fields?.password||"password"},...m?.fields},order:3},verification:{modelName:e.verification?.modelName||"verification",fields:{identifier:{type:"string",required:!0,fieldName:e.verification?.fields?.identifier||"identifier"},value:{type:"string",required:!0,fieldName:e.verification?.fields?.value||"value"},expiresAt:{type:"date",required:!0,fieldName:e.verification?.fields?.expiresAt||"expiresAt"},createdAt:{type:"date",required:!1,defaultValue:()=>new Date,fieldName:e.verification?.fields?.createdAt||"createdAt"}},order:4},...A,...d?u:{}}};var v=require("zod");function ae(e){return v.z.object({...Object.keys(e).reduce((d,u)=>{let p=e[u];if(!p)return d;if(p.type==="string[]"||p.type==="number[]")return{...d,[u]:v.z.array(p.type==="string[]"?v.z.string():v.z.number())};let g=v.z[p.type]();return p?.required===!1&&(g=g.optional()),p?.returned===!1?d:{...d,[u]:g}},{})})}var I=class extends Error{constructor(n,d){super(n),this.name="BetterAuthError",this.message=n,this.cause=d,this.stack=""}};var N=require("kysely"),w=require("kysely");function $(e){if("dialect"in e)return $(e.dialect);if("createDriver"in e){if(e instanceof w.SqliteDialect)return"sqlite";if(e instanceof w.MysqlDialect)return"mysql";if(e instanceof w.PostgresDialect)return"postgres";if(e instanceof N.MssqlDialect)return"mssql"}return"aggregate"in e?"sqlite":"getConnection"in e?"mysql":"connect"in e?"postgres":null}var R=async e=>{let n=e.database;if("db"in n)return{kysely:n.db,databaseType:n.type};if("dialect"in n)return{kysely:new N.Kysely({dialect:n.dialect}),databaseType:n.type};let d,u=$(n);return"createDriver"in n&&(d=n),"aggregate"in n&&(d=new w.SqliteDialect({database:n})),"getConnection"in n&&(d=new w.MysqlDialect(n)),"connect"in n&&(d=new w.PostgresDialect({pool:n})),{kysely:d?new N.Kysely({dialect:d}):null,databaseType:u}};var oe=(e,n,d)=>{let u=k(n);function p(t,i){if(i==="id")return i;let c=u[t].fields[i];return c||console.log("Field not found",t,i),c.fieldName||i}function g(t,i,c){let{type:o="sqlite"}=d||{},a=u[i].fields[c];return a.type==="boolean"&&o==="sqlite"?t?1:0:a.type==="date"&&t&&t instanceof Date&&o==="sqlite"?t.toISOString():t}function m(t,i,c){let{type:o="sqlite"}=d||{},a=u[i].fields[c];return a.type==="boolean"&&o==="sqlite"&&t!==null?t===1:a.type==="date"&&t?new Date(t):t}function A(t){return u[t].modelName}let r=d?.generateId!==!1;return{transformInput(t,i){let c=t.id&&r?{id:d?.generateId?d.generateId():t.id}:{};for(let o in t){let a=u[i].fields[o];a&&(c[a.fieldName||o]=g(t[o],i,o))}return c},transformOutput(t,i,c=[]){if(!t)return null;let o=t.id?c.length===0||c.includes("id")?{id:t.id}:{}:{},a=u[i].fields;for(let s in a){if(c.length&&!c.includes(s))continue;let l=a[s];l&&(o[s]=m(t[l.fieldName||s],i,s))}return o},convertWhereClause(t,i){if(!i)return{and:null,or:null};let c={and:[],or:[]};return i.forEach(o=>{let{field:a,value:s,operator:l="=",connector:y="AND"}=o,f=p(t,a),h=b=>l.toLowerCase()==="in"?b(f,"in",Array.isArray(s)?s:[s]):l==="contains"?b(f,"like",`%${s}%`):l==="starts_with"?b(f,"like",`${s}%`):l==="ends_with"?b(f,"like",`%${s}`):l==="eq"?b(f,"=",s):l==="ne"?b(f,"<>",s):l==="gt"?b(f,">",s):l==="gte"?b(f,">=",s):l==="lt"?b(f,"<",s):l==="lte"?b(f,"<=",s):b(f,l,s);y==="OR"?c.or.push(h):c.and.push(h)}),{and:c.and.length?c.and:null,or:c.or.length?c.or:null}},async withReturning(t,i,c,o){let a;if(d?.type!=="mysql")a=await i.returningAll().executeTakeFirst();else{await i.execute();let s=t.id?"id":o[0].field?o[0].field:"id",l=t[s]||o[0].value;a=await e.selectFrom(A(c)).selectAll().where(p(c,s),"=",l).executeTakeFirst()}return a},getModelName:A,getField:p}},_=(e,n)=>d=>{let{transformInput:u,withReturning:p,transformOutput:g,convertWhereClause:m,getModelName:A,getField:r}=oe(e,d,n);return{id:"kysely",async create(t){let{model:i,data:c,select:o}=t,a=u(c,i),s=e.insertInto(A(i)).values(a);return g(await p(a,s,i,[]),i,o)},async findOne(t){let{model:i,where:c,select:o}=t,{and:a,or:s}=m(i,c),l=e.selectFrom(A(i)).selectAll();a&&(l=l.where(f=>f.and(a.map(h=>h(f))))),s&&(l=l.where(f=>f.or(s.map(h=>h(f)))));let y=await l.executeTakeFirst();return y?g(y,i,o):null},async findMany(t){let{model:i,where:c,limit:o,offset:a,sortBy:s}=t,{and:l,or:y}=m(i,c),f=e.selectFrom(A(i));l&&(f=f.where(b=>b.and(l.map(F=>F(b))))),y&&(f=f.where(b=>b.or(y.map(F=>F(b))))),f=f.limit(o||100),a&&(f=f.offset(a)),s&&(f=f.orderBy(r(i,s.field),s.direction));let h=await f.selectAll().execute();return h?h.map(b=>g(b,i)):[]},async update(t){let{model:i,where:c,update:o}=t,{and:a,or:s}=m(i,c),l=u(o,i),y=e.updateTable(A(i)).set(l);return a&&(y=y.where(f=>f.and(a.map(h=>h(f))))),s&&(y=y.where(f=>f.or(s.map(h=>h(f))))),g(await p(l,y,i,c),i)},async updateMany(t){let{model:i,where:c,update:o}=t,{and:a,or:s}=m(i,c),l=u(o,i),y=e.updateTable(A(i)).set(l);return a&&(y=y.where(h=>h.and(a.map(b=>b(h))))),s&&(y=y.where(h=>h.or(s.map(b=>b(h))))),(await y.execute()).length},async delete(t){let{model:i,where:c}=t,{and:o,or:a}=m(i,c),s=e.deleteFrom(A(i));o&&(s=s.where(l=>l.and(o.map(y=>y(l))))),a&&(s=s.where(l=>l.or(a.map(y=>y(l))))),await s.execute()},async deleteMany(t){let{model:i,where:c}=t,{and:o,or:a}=m(i,c),s=e.deleteFrom(A(i));return o&&(s=s.where(l=>l.and(o.map(y=>y(l))))),a&&(s=s.where(l=>l.or(a.map(y=>y(l))))),(await s.execute()).length},options:n}};async function de(e){if(!e.database)throw new I("Database configuration is required");if(typeof e.database=="function")return e.database(e);let{kysely:n,databaseType:d}=await R(e);if(!n)throw new I("Failed to initialize database adapter");return _(n,{generateId:"generateId"in e.database?e.database.generateId:void 0,type:d||"sqlite"})(e)}function le(e,n){let d=n.id?{id:n.id}:{};for(let u in e){let p=e[u],g=n[u];g!==void 0&&(d[p.fieldName||u]=g)}return d}function ue(e,n){if(!n)return null;let d={id:n.id};for(let[u,p]of Object.entries(e))d[u]=n[p.fieldName||u];return d}var J=require("consola"),M=["info","success","warn","error","debug"];function ce(e,n){return M.indexOf(n)<=M.indexOf(e)}var fe=(0,J.createConsola)({formatOptions:{date:!1,colors:!0,compact:!0},defaults:{tag:"Better Auth"}}),U=e=>{let n=e?.disabled!==!0,d=e?.level??"error",u=(p,g,m=[])=>{if(!(!n||!ce(d,p))){if(!e||typeof e.log!="function"){fe[p]("",g,...m);return}e.log(p==="success"?"info":p,g,m)}};return Object.fromEntries(M.map(p=>[p,(...[g,...m])=>u(p,g,m)]))},nt=U();function j(e){let n=k(e),d={};for(let u in n){let p=n[u],g=p.fields,m={};if(Object.entries(g).forEach(([A,r])=>{if(m[r.fieldName||A]=r,r.references){let t=n[r.references.model];t&&(m[r.fieldName||A].references={model:t.modelName,field:r.references.field})}}),d[p.modelName]){d[p.modelName].fields={...d[p.modelName].fields,...m};continue}d[p.modelName]={fields:m,order:p.order||1/0}}return d}var pe={string:["character varying","text"],number:["int4","integer","bigint","smallint","numeric","real","double precision"],boolean:["bool","boolean"],date:["timestamp","date"]},ye={string:["varchar","text"],number:["integer","int","bigint","smallint","decimal","float","double"],boolean:["boolean","tinyint"],date:["timestamp","datetime","date"]},me={string:["TEXT"],number:["INTEGER","REAL"],boolean:["INTEGER","BOOLEAN"],date:["DATE","INTEGER"]},ge={string:["nvarchar","varchar"],number:["int","bigint","smallint","decimal","float","double"],boolean:["bit","boolean"],date:["datetime","date"]},he={postgres:pe,mysql:ye,sqlite:me,mssql:ge};function z(e,n,d){return n==="string[]"||n==="number[]"?e.toLowerCase().includes("json"):he[d][n].map(m=>m.toLowerCase()).includes(e.toLowerCase())}async function Ae(e){let n=j(e),d=U(e.logger),{kysely:u,databaseType:p}=await R(e);p||(d.warn("Could not determine database type, defaulting to sqlite. Please provide a type in the database options to avoid this."),p="sqlite"),u||(d.error("Only kysely adapter is supported for migrations. You can use `generate` command to generate the schema, if you're using a different adapter."),process.exit(1));let g=await u.introspection.getTables(),m=[],A=[];for(let[o,a]of Object.entries(n)){let s=g.find(y=>y.name===o);if(!s){let y=m.findIndex(b=>b.table===o),f={table:o,fields:a.fields,order:a.order||1/0},h=m.findIndex(b=>(b.order||1/0)>f.order);h===-1?y===-1?m.push(f):m[y].fields={...m[y].fields,...a.fields}:m.splice(h,0,f);continue}let l={};for(let[y,f]of Object.entries(a.fields)){let h=s.columns.find(b=>b.name===y);if(!h){l[y]=f;continue}z(h.dataType,f.type,p)||d.warn(`Field ${y} in table ${o} has a different type in the database. Expected ${f.type} but got ${h.dataType}.`)}Object.keys(l).length>0&&A.push({table:o,fields:l,order:a.order||1/0})}let r=[];function t(o){let a=o.type,s={string:{sqlite:"text",postgres:"text",mysql:o.unique?"varchar(255)":o.references?"varchar(36)":"text",mssql:"text"},boolean:{sqlite:"integer",postgres:"boolean",mysql:"boolean",mssql:"boolean"},number:{sqlite:"integer",postgres:"integer",mysql:"integer",mssql:"integer"},date:{sqlite:"date",postgres:"timestamp",mysql:"datetime",mssql:"datetime"}};return p==="sqlite"&&(a==="string[]"||a==="number[]")?"text":a==="string[]"||a==="number[]"?"jsonb":s[a][p||"sqlite"]}if(A.length)for(let o of A)for(let[a,s]of Object.entries(o.fields)){let l=t(s),y=u.schema.alterTable(o.table).addColumn(a,l,f=>(f=s.required!==!1?f.notNull():f,s.references&&(f=f.references(`${s.references.model}.${s.references.field}`)),f));r.push(y)}if(m.length)for(let o of m){let a=u.schema.createTable(o.table).addColumn("id",p==="mysql"?"varchar(36)":"text",s=>s.primaryKey().notNull());for(let[s,l]of Object.entries(o.fields)){let y=t(l);a=a.addColumn(s,y,f=>(f=l.required!==!1?f.notNull():f,l.references&&(f=f.references(`${l.references.model}.${l.references.field}`)),l.unique&&(f=f.unique()),f))}r.push(a)}async function i(){for(let o of r)await o.execute()}async function c(){return r.map(a=>a.compile().sql).join(`;

`)}return{toBeCreated:m,toBeAdded:A,runMigrations:i,compileMigrations:c}}0&&(module.exports={convertFromDB,convertToDB,createFieldAttribute,createInternalAdapter,getAdapter,getAuthTables,getMigrations,getSchema,getWithHooks,matchType,toZodSchema});
