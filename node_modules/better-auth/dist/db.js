var D=(e,s="ms")=>new Date(Date.now()+(s==="sec"?e*1e3:e));import{z as x}from"zod";var ue=x.object({id:x.string(),providerId:x.string(),accountId:x.string(),userId:x.string(),accessToken:x.string().nullish(),refreshToken:x.string().nullish(),idToken:x.string().nullish(),expiresAt:x.date().nullish(),password:x.string().nullish()}),ce=x.object({id:x.string(),email:x.string().transform(e=>e.toLowerCase()),emailVerified:x.boolean().default(!1),name:x.string(),image:x.string().nullish(),createdAt:x.date().default(new Date),updatedAt:x.date().default(new Date)}),fe=x.object({id:x.string(),userId:x.string(),expiresAt:x.date(),ipAddress:x.string().nullish(),userAgent:x.string().nullish()}),pe=x.object({id:x.string(),value:x.string(),createdAt:x.date(),expiresAt:x.date(),identifier:x.string()});function L(e,s){let l=s.fields,u={};for(let p in e){let g=l[p];if(!g){u[p]=e[p];continue}g.returned!==!1&&(u[p]=e[p])}return u}function P(e,s){let l={...s==="user"?e.user?.additionalFields:{},...s==="session"?e.session?.additionalFields:{}};for(let u of e.plugins||[])u.schema&&u.schema[s]&&(l={...l,...u.schema[s].fields});return l}function R(e,s){let l=P(e,"user");return L(s,{fields:l})}function k(e,s){let l=P(e,"session");return L(s,{fields:l})}import{nanoid as J}from"nanoid";var w=e=>J(e);function M(e,s){let l=s.hooks;async function u(m,A,r){let t=m;for(let o of l||[]){let a=o[A]?.create?.before;if(a){let i=await a(m);if(i===!1)return null;typeof i=="object"&&"data"in i&&(t=i.data)}}let n=r?await r.fn(t):null,c=!r||r.executeMainFn?await e.create({model:A,data:t}):n;for(let o of l||[]){let a=o[A]?.create?.after;a&&await a(c)}return c}async function p(m,A,r,t){let n=m;for(let a of l||[]){let i=a[r]?.update?.before;if(i){let d=await i(m);if(d===!1)return null;n=typeof d=="object"?d.data:d}}let c=t?await t.fn(n):null,o=!t||t.executeMainFn?await e.update({model:r,update:n,where:A}):c;for(let a of l||[]){let i=a[r]?.update?.after;i&&await i(o)}return o}async function g(m,A,r,t){let n=m;for(let a of l||[]){let i=a[r]?.update?.before;if(i){let d=await i(m);if(d===!1)return null;n=typeof d=="object"?d.data:d}}let c=t?await t.fn(n):null,o=!t||t.executeMainFn?await e.updateMany({model:r,update:n,where:A}):c;for(let a of l||[]){let i=a[r]?.update?.after;i&&await i(o)}return o}return{createWithHooks:u,updateWithHooks:p,updateManyWithHooks:g}}var I=Object.create(null),v=e=>globalThis.process?.env||globalThis.Deno?.env.toObject()||globalThis.__env__||(e?I:globalThis),z=new Proxy(I,{get(e,s){return v()[s]??I[s]},has(e,s){let l=v();return s in l||s in I},set(e,s,l){let u=v(!0);return u[s]=l,!0},deleteProperty(e,s){if(!s)return!1;let l=v(!0);return delete l[s],!0},ownKeys(){let e=v(!0);return Object.keys(e)}});function Z(e){return e?e!=="false":!1}var G=typeof process<"u"&&process.env&&process.env.NODE_ENV||"";var U=G==="test"||Z(z.TEST);function j(e,s){if(s.advanced?.ipAddress?.disableIpTracking)return null;let l="127.0.0.1";if(U)return l;let p=s.advanced?.ipAddress?.ipAddressHeaders||["x-client-ip","x-forwarded-for","cf-connecting-ip","fastly-client-ip","x-real-ip","x-cluster-client-ip","x-forwarded","forwarded-for","forwarded"],g=e instanceof Request?e.headers:e;for(let m of p){let A=g.get(m);if(typeof A=="string"){let r=A.split(",")[0].trim();if(r)return r}}return null}function N(e){try{return JSON.parse(e)}catch{return null}}var Ne=(e,s)=>{let l=s.options,u=l.secondaryStorage,p=l.session?.expiresIn||60*60*24*7,{createWithHooks:g,updateWithHooks:m,updateManyWithHooks:A}=M(e,s);return{createOAuthUser:async(r,t)=>{try{let n=await g({id:w(),createdAt:new Date,updatedAt:new Date,...r},"user"),c=await g({id:w(),...t,userId:n.id||r.id},"account");return{user:n,account:c}}catch(n){return console.log(n),null}},createUser:async r=>await g({id:w(),createdAt:new Date,updatedAt:new Date,emailVerified:!1,...r},"user"),createAccount:async r=>await g({id:w(),createdAt:new Date,updatedAt:new Date,...r},"account"),listSessions:async r=>{if(u){let n=await u.get(`active-sessions-${r}`);if(!n)return[];let c=N(n)||[],o=Date.now(),a=c.filter(d=>d.expiresAt>o),i=[];for(let d of a){let y=await u.get(d.id);if(y){let f=JSON.parse(y),h=k(s.options,{...f.session,expiresAt:new Date(f.session.expiresAt)});i.push(h)}}return i}return await e.findMany({model:"session",where:[{field:"userId",value:r}]})},listUsers:async(r,t,n,c)=>await e.findMany({model:"user",limit:r,offset:t,sortBy:n,where:c}),deleteUser:async r=>{await e.deleteMany({model:"session",where:[{field:"userId",value:r}]}),await e.deleteMany({model:"account",where:[{field:"userId",value:r}]}),await e.delete({model:"user",where:[{field:"id",value:r}]})},createSession:async(r,t,n,c)=>{let o=t instanceof Request?t.headers:t,a={expiresAt:n?D(60*60*24,"sec"):D(p,"sec"),ipAddress:t&&j(t,s.options)||"",userAgent:o?.get("user-agent")||"",...c,id:w(32),userId:r};return await g(a,"session",u?{fn:async d=>{let y=await e.findOne({model:"user",where:[{field:"id",value:r}]});u.set(d.id,JSON.stringify({session:d,user:y}),p);let f=await u.get(`active-sessions-${r}`),h=[],b=Date.now();return f&&(h=N(f)||[],h=h.filter(T=>T.expiresAt>b)),h.push({id:d.id,expiresAt:b+p*1e3}),await u.set(`active-sessions-${r}`,JSON.stringify(h),p),d},executeMainFn:l.session?.storeSessionInDatabase}:void 0)},findSession:async r=>{if(u){let o=await u.get(r);if(o){let a=JSON.parse(o),i=k(s.options,{...a.session,expiresAt:new Date(a.session.expiresAt)}),d=R(s.options,{...a.user,createdAt:new Date(a.user.createdAt),updatedAt:new Date(a.user.updatedAt)});return{session:i,user:d}}}let t=await e.findOne({model:"session",where:[{value:r,field:"id"}]});if(!t)return null;let n=await e.findOne({model:"user",where:[{value:t.userId,field:"id"}]});if(!n)return null;let c=R(s.options,n);return{session:k(s.options,t),user:c}},findSessions:async r=>{if(u){let o=[];for(let a of r){let i=await u.get(a);if(i){let d=JSON.parse(i),y={session:{...d.session,expiresAt:new Date(d.session.expiresAt)},user:{...d.user,createdAt:new Date(d.user.createdAt),updatedAt:new Date(d.user.updatedAt)}};o.push(y)}}return o}let t=await e.findMany({model:"session",where:[{field:"id",value:r,operator:"in"}]}),n=t.map(o=>o.userId);if(!n.length)return[];let c=await e.findMany({model:"user",where:[{field:"id",value:n,operator:"in"}]});return t.map(o=>{let a=c.find(i=>i.id===o.userId);return a?{session:o,user:a}:null})},updateSession:async(r,t)=>await m(t,[{field:"id",value:r}],"session",u?{async fn(c){let o=await u.get(r),a=null;if(o){let i=JSON.parse(o);a={...i.session,...c},await u.set(r,JSON.stringify({session:a,user:i.user}),i.session.expiresAt?Math.floor((i.session.expiresAt.getTime()-Date.now())/1e3):p)}else return null},executeMainFn:l.session?.storeSessionInDatabase}:void 0),deleteSession:async r=>{if(u){await u.delete(r),l.session?.storeSessionInDatabase&&await e.delete({model:"session",where:[{field:"id",value:r}]});return}await e.delete({model:"session",where:[{field:"id",value:r}]})},deleteSessions:async r=>{if(u){if(typeof r=="string"){let t=await u.get(`active-sessions-${r}`),n=t?N(t):[];if(!n)return;for(let c of n)await u.delete(c.id)}else for(let t of r)await u.get(t)&&await u.delete(t);l.session?.storeSessionInDatabase&&await e.deleteMany({model:"session",where:[{field:Array.isArray(r)?"id":"userId",value:r,operator:Array.isArray(r)?"in":void 0}]});return}await e.deleteMany({model:"session",where:[{field:Array.isArray(r)?"id":"userId",value:r,operator:Array.isArray(r)?"in":void 0}]})},findUserByEmail:async(r,t)=>{let n=await e.findOne({model:"user",where:[{value:r.toLowerCase(),field:"email"}]});if(!n)return null;if(t?.includeAccounts){let c=await e.findMany({model:"account",where:[{value:n.id,field:"userId"}]});return{user:n,accounts:c}}return{user:n,accounts:[]}},findUserById:async r=>await e.findOne({model:"user",where:[{field:"id",value:r}]}),linkAccount:async r=>await g({id:w(),...r},"account"),updateUser:async(r,t)=>await m(t,[{field:"id",value:r}],"user"),updateUserByEmail:async(r,t)=>await m(t,[{field:"email",value:r}],"user"),updatePassword:async(r,t)=>{await A({password:t},[{field:"userId",value:r},{field:"providerId",value:"credential"}],"account")},findAccounts:async r=>await e.findMany({model:"account",where:[{field:"userId",value:r}]}),findAccount:async r=>await e.findOne({model:"account",where:[{field:"accountId",value:r}]}),findAccountByUserId:async r=>await e.findMany({model:"account",where:[{field:"userId",value:r}]}),updateAccount:async(r,t)=>await m(t,[{field:"id",value:r}],"account"),createVerificationValue:async r=>await g({id:w(),createdAt:new Date,...r},"verification"),findVerificationValue:async r=>(await e.findMany({model:"verification",where:[{field:"identifier",value:r}],sortBy:{field:"createdAt",direction:"desc"},limit:10}))[0],deleteVerificationValue:async r=>{await e.delete({model:"verification",where:[{field:"id",value:r}]})},deleteVerificationByIdentifier:async r=>{await e.delete({model:"verification",where:[{field:"identifier",value:r}]})},updateVerificationValue:async(r,t)=>await m(t,[{field:"id",value:r}],"verification")}};var Se=(e,s)=>({type:e,...s});var q=e=>{let s=e.plugins?.reduce((r,t)=>{let n=t.schema;if(!n)return r;for(let[c,o]of Object.entries(n))r[c]={fields:{...r[c]?.fields,...o.fields},modelName:o.modelName||c};return r},{}),l=e.rateLimit?.storage==="database",u={rateLimit:{modelName:e.rateLimit?.modelName||"rateLimit",fields:{key:{type:"string",fieldName:e.rateLimit?.fields?.key||"key"},count:{type:"number",fieldName:e.rateLimit?.fields?.count||"count"},lastRequest:{type:"number",fieldName:e.rateLimit?.fields?.lastRequest||"lastRequest"}}}},{user:p,session:g,account:m,...A}=s||{};return{user:{modelName:e.user?.modelName||"user",fields:{name:{type:"string",required:!0,fieldName:e.user?.fields?.name||"name"},email:{type:"string",unique:!0,required:!0,fieldName:e.user?.fields?.email||"email"},emailVerified:{type:"boolean",defaultValue:()=>!1,required:!0,fieldName:e.user?.fields?.emailVerified||"emailVerified"},image:{type:"string",required:!1,fieldName:e.user?.fields?.image||"image"},createdAt:{type:"date",defaultValue:()=>new Date,required:!0,fieldName:e.user?.fields?.createdAt||"createdAt"},updatedAt:{type:"date",defaultValue:()=>new Date,required:!0,fieldName:e.user?.fields?.updatedAt||"updatedAt"},...p?.fields,...e.user?.additionalFields},order:1},session:{modelName:e.session?.modelName||"session",fields:{expiresAt:{type:"date",required:!0,fieldName:e.session?.fields?.expiresAt||"expiresAt"},ipAddress:{type:"string",required:!1,fieldName:e.session?.fields?.ipAddress||"ipAddress"},userAgent:{type:"string",required:!1,fieldName:e.session?.fields?.userAgent||"userAgent"},userId:{type:"string",fieldName:e.session?.fields?.userId||"userId",references:{model:e.user?.modelName||"user",field:"id",onDelete:"cascade"},required:!0},...g?.fields,...e.session?.additionalFields},order:2},account:{modelName:e.account?.modelName||"account",fields:{accountId:{type:"string",required:!0,fieldName:e.account?.fields?.accountId||"accountId"},providerId:{type:"string",required:!0,fieldName:e.account?.fields?.providerId||"providerId"},userId:{type:"string",references:{model:e.user?.modelName||"user",field:"id",onDelete:"cascade"},required:!0,fieldName:e.account?.fields?.userId||"userId"},accessToken:{type:"string",required:!1,fieldName:e.account?.fields?.accessToken||"accessToken"},refreshToken:{type:"string",required:!1,fieldName:e.account?.fields?.refreshToken||"refreshToken"},idToken:{type:"string",required:!1,fieldName:e.account?.fields?.idToken||"idToken"},expiresAt:{type:"date",required:!1,fieldName:e.account?.fields?.expiresAt||"expiresAt"},password:{type:"string",required:!1,fieldName:e.account?.fields?.password||"password"},...m?.fields},order:3},verification:{modelName:e.verification?.modelName||"verification",fields:{identifier:{type:"string",required:!0,fieldName:e.verification?.fields?.identifier||"identifier"},value:{type:"string",required:!0,fieldName:e.verification?.fields?.value||"value"},expiresAt:{type:"date",required:!0,fieldName:e.verification?.fields?.expiresAt||"expiresAt"},createdAt:{type:"date",required:!1,defaultValue:()=>new Date,fieldName:e.verification?.fields?.createdAt||"createdAt"}},order:4},...A,...l?u:{}}};import{z as F}from"zod";function Ve(e){return F.object({...Object.keys(e).reduce((l,u)=>{let p=e[u];if(!p)return l;if(p.type==="string[]"||p.type==="number[]")return{...l,[u]:F.array(p.type==="string[]"?F.string():F.number())};let g=F[p.type]();return p?.required===!1&&(g=g.optional()),p?.returned===!1?l:{...l,[u]:g}},{})})}var O=class extends Error{constructor(s,l){super(s),this.name="BetterAuthError",this.message=s,this.cause=l,this.stack=""}};import{Kysely as K,MssqlDialect as Q}from"kysely";import{MysqlDialect as E,PostgresDialect as C,SqliteDialect as H}from"kysely";function W(e){if("dialect"in e)return W(e.dialect);if("createDriver"in e){if(e instanceof H)return"sqlite";if(e instanceof E)return"mysql";if(e instanceof C)return"postgres";if(e instanceof Q)return"mssql"}return"aggregate"in e?"sqlite":"getConnection"in e?"mysql":"connect"in e?"postgres":null}var S=async e=>{let s=e.database;if("db"in s)return{kysely:s.db,databaseType:s.type};if("dialect"in s)return{kysely:new K({dialect:s.dialect}),databaseType:s.type};let l,u=W(s);return"createDriver"in s&&(l=s),"aggregate"in s&&(l=new H({database:s})),"getConnection"in s&&(l=new E(s)),"connect"in s&&(l=new C({pool:s})),{kysely:l?new K({dialect:l}):null,databaseType:u}};var X=(e,s,l)=>{let u=q(s);function p(t,n){if(n==="id")return n;let c=u[t].fields[n];return c||console.log("Field not found",t,n),c.fieldName||n}function g(t,n,c){let{type:o="sqlite"}=l||{},a=u[n].fields[c];return a.type==="boolean"&&o==="sqlite"?t?1:0:a.type==="date"&&t&&t instanceof Date&&o==="sqlite"?t.toISOString():t}function m(t,n,c){let{type:o="sqlite"}=l||{},a=u[n].fields[c];return a.type==="boolean"&&o==="sqlite"&&t!==null?t===1:a.type==="date"&&t?new Date(t):t}function A(t){return u[t].modelName}let r=l?.generateId!==!1;return{transformInput(t,n){let c=t.id&&r?{id:l?.generateId?l.generateId():t.id}:{};for(let o in t){let a=u[n].fields[o];a&&(c[a.fieldName||o]=g(t[o],n,o))}return c},transformOutput(t,n,c=[]){if(!t)return null;let o=t.id?c.length===0||c.includes("id")?{id:t.id}:{}:{},a=u[n].fields;for(let i in a){if(c.length&&!c.includes(i))continue;let d=a[i];d&&(o[i]=m(t[d.fieldName||i],n,i))}return o},convertWhereClause(t,n){if(!n)return{and:null,or:null};let c={and:[],or:[]};return n.forEach(o=>{let{field:a,value:i,operator:d="=",connector:y="AND"}=o,f=p(t,a),h=b=>d.toLowerCase()==="in"?b(f,"in",Array.isArray(i)?i:[i]):d==="contains"?b(f,"like",`%${i}%`):d==="starts_with"?b(f,"like",`${i}%`):d==="ends_with"?b(f,"like",`%${i}`):d==="eq"?b(f,"=",i):d==="ne"?b(f,"<>",i):d==="gt"?b(f,">",i):d==="gte"?b(f,">=",i):d==="lt"?b(f,"<",i):d==="lte"?b(f,"<=",i):b(f,d,i);y==="OR"?c.or.push(h):c.and.push(h)}),{and:c.and.length?c.and:null,or:c.or.length?c.or:null}},async withReturning(t,n,c,o){let a;if(l?.type!=="mysql")a=await n.returningAll().executeTakeFirst();else{await n.execute();let i=t.id?"id":o[0].field?o[0].field:"id",d=t[i]||o[0].value;a=await e.selectFrom(A(c)).selectAll().where(p(c,i),"=",d).executeTakeFirst()}return a},getModelName:A,getField:p}},$=(e,s)=>l=>{let{transformInput:u,withReturning:p,transformOutput:g,convertWhereClause:m,getModelName:A,getField:r}=X(e,l,s);return{id:"kysely",async create(t){let{model:n,data:c,select:o}=t,a=u(c,n),i=e.insertInto(A(n)).values(a);return g(await p(a,i,n,[]),n,o)},async findOne(t){let{model:n,where:c,select:o}=t,{and:a,or:i}=m(n,c),d=e.selectFrom(A(n)).selectAll();a&&(d=d.where(f=>f.and(a.map(h=>h(f))))),i&&(d=d.where(f=>f.or(i.map(h=>h(f)))));let y=await d.executeTakeFirst();return y?g(y,n,o):null},async findMany(t){let{model:n,where:c,limit:o,offset:a,sortBy:i}=t,{and:d,or:y}=m(n,c),f=e.selectFrom(A(n));d&&(f=f.where(b=>b.and(d.map(T=>T(b))))),y&&(f=f.where(b=>b.or(y.map(T=>T(b))))),f=f.limit(o||100),a&&(f=f.offset(a)),i&&(f=f.orderBy(r(n,i.field),i.direction));let h=await f.selectAll().execute();return h?h.map(b=>g(b,n)):[]},async update(t){let{model:n,where:c,update:o}=t,{and:a,or:i}=m(n,c),d=u(o,n),y=e.updateTable(A(n)).set(d);return a&&(y=y.where(f=>f.and(a.map(h=>h(f))))),i&&(y=y.where(f=>f.or(i.map(h=>h(f))))),g(await p(d,y,n,c),n)},async updateMany(t){let{model:n,where:c,update:o}=t,{and:a,or:i}=m(n,c),d=u(o,n),y=e.updateTable(A(n)).set(d);return a&&(y=y.where(h=>h.and(a.map(b=>b(h))))),i&&(y=y.where(h=>h.or(i.map(b=>b(h))))),(await y.execute()).length},async delete(t){let{model:n,where:c}=t,{and:o,or:a}=m(n,c),i=e.deleteFrom(A(n));o&&(i=i.where(d=>d.and(o.map(y=>y(d))))),a&&(i=i.where(d=>d.or(a.map(y=>y(d))))),await i.execute()},async deleteMany(t){let{model:n,where:c}=t,{and:o,or:a}=m(n,c),i=e.deleteFrom(A(n));return o&&(i=i.where(d=>d.and(o.map(y=>y(d))))),a&&(i=i.where(d=>d.or(a.map(y=>y(d))))),(await i.execute()).length},options:s}};async function Qe(e){if(!e.database)throw new O("Database configuration is required");if(typeof e.database=="function")return e.database(e);let{kysely:s,databaseType:l}=await S(e);if(!s)throw new O("Failed to initialize database adapter");return $(s,{generateId:"generateId"in e.database?e.database.generateId:void 0,type:l||"sqlite"})(e)}function Xe(e,s){let l=s.id?{id:s.id}:{};for(let u in e){let p=e[u],g=s[u];g!==void 0&&(l[p.fieldName||u]=g)}return l}function Ye(e,s){if(!s)return null;let l={id:s.id};for(let[u,p]of Object.entries(e))l[u]=s[p.fieldName||u];return l}import{createConsola as Y}from"consola";var B=["info","success","warn","error","debug"];function ee(e,s){return B.indexOf(s)<=B.indexOf(e)}var te=Y({formatOptions:{date:!1,colors:!0,compact:!0},defaults:{tag:"Better Auth"}}),V=e=>{let s=e?.disabled!==!0,l=e?.level??"error",u=(p,g,m=[])=>{if(!(!s||!ee(l,p))){if(!e||typeof e.log!="function"){te[p]("",g,...m);return}e.log(p==="success"?"info":p,g,m)}};return Object.fromEntries(B.map(p=>[p,(...[g,...m])=>u(p,g,m)]))},rt=V();function _(e){let s=q(e),l={};for(let u in s){let p=s[u],g=p.fields,m={};if(Object.entries(g).forEach(([A,r])=>{if(m[r.fieldName||A]=r,r.references){let t=s[r.references.model];t&&(m[r.fieldName||A].references={model:t.modelName,field:r.references.field})}}),l[p.modelName]){l[p.modelName].fields={...l[p.modelName].fields,...m};continue}l[p.modelName]={fields:m,order:p.order||1/0}}return l}var re={string:["character varying","text"],number:["int4","integer","bigint","smallint","numeric","real","double precision"],boolean:["bool","boolean"],date:["timestamp","date"]},ne={string:["varchar","text"],number:["integer","int","bigint","smallint","decimal","float","double"],boolean:["boolean","tinyint"],date:["timestamp","datetime","date"]},ie={string:["TEXT"],number:["INTEGER","REAL"],boolean:["INTEGER","BOOLEAN"],date:["DATE","INTEGER"]},se={string:["nvarchar","varchar"],number:["int","bigint","smallint","decimal","float","double"],boolean:["bit","boolean"],date:["datetime","date"]},ae={postgres:re,mysql:ne,sqlite:ie,mssql:se};function oe(e,s,l){return s==="string[]"||s==="number[]"?e.toLowerCase().includes("json"):ae[l][s].map(m=>m.toLowerCase()).includes(e.toLowerCase())}async function lt(e){let s=_(e),l=V(e.logger),{kysely:u,databaseType:p}=await S(e);p||(l.warn("Could not determine database type, defaulting to sqlite. Please provide a type in the database options to avoid this."),p="sqlite"),u||(l.error("Only kysely adapter is supported for migrations. You can use `generate` command to generate the schema, if you're using a different adapter."),process.exit(1));let g=await u.introspection.getTables(),m=[],A=[];for(let[o,a]of Object.entries(s)){let i=g.find(y=>y.name===o);if(!i){let y=m.findIndex(b=>b.table===o),f={table:o,fields:a.fields,order:a.order||1/0},h=m.findIndex(b=>(b.order||1/0)>f.order);h===-1?y===-1?m.push(f):m[y].fields={...m[y].fields,...a.fields}:m.splice(h,0,f);continue}let d={};for(let[y,f]of Object.entries(a.fields)){let h=i.columns.find(b=>b.name===y);if(!h){d[y]=f;continue}oe(h.dataType,f.type,p)||l.warn(`Field ${y} in table ${o} has a different type in the database. Expected ${f.type} but got ${h.dataType}.`)}Object.keys(d).length>0&&A.push({table:o,fields:d,order:a.order||1/0})}let r=[];function t(o){let a=o.type,i={string:{sqlite:"text",postgres:"text",mysql:o.unique?"varchar(255)":o.references?"varchar(36)":"text",mssql:"text"},boolean:{sqlite:"integer",postgres:"boolean",mysql:"boolean",mssql:"boolean"},number:{sqlite:"integer",postgres:"integer",mysql:"integer",mssql:"integer"},date:{sqlite:"date",postgres:"timestamp",mysql:"datetime",mssql:"datetime"}};return p==="sqlite"&&(a==="string[]"||a==="number[]")?"text":a==="string[]"||a==="number[]"?"jsonb":i[a][p||"sqlite"]}if(A.length)for(let o of A)for(let[a,i]of Object.entries(o.fields)){let d=t(i),y=u.schema.alterTable(o.table).addColumn(a,d,f=>(f=i.required!==!1?f.notNull():f,i.references&&(f=f.references(`${i.references.model}.${i.references.field}`)),f));r.push(y)}if(m.length)for(let o of m){let a=u.schema.createTable(o.table).addColumn("id",p==="mysql"?"varchar(36)":"text",i=>i.primaryKey().notNull());for(let[i,d]of Object.entries(o.fields)){let y=t(d);a=a.addColumn(i,y,f=>(f=d.required!==!1?f.notNull():f,d.references&&(f=f.references(`${d.references.model}.${d.references.field}`)),d.unique&&(f=f.unique()),f))}r.push(a)}async function n(){for(let o of r)await o.execute()}async function c(){return r.map(a=>a.compile().sql).join(`;

`)}return{toBeCreated:m,toBeAdded:A,runMigrations:n,compileMigrations:c}}export{Ye as convertFromDB,Xe as convertToDB,Se as createFieldAttribute,Ne as createInternalAdapter,Qe as getAdapter,q as getAuthTables,lt as getMigrations,_ as getSchema,M as getWithHooks,oe as matchType,Ve as toZodSchema};
