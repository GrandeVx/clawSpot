import{APIError as ve,createRouter as jr,statusCode as zr}from"better-call";import{APIError as Kt}from"better-call";import{createEndpointCreator as Ht,createMiddleware as Ie,createMiddlewareCreator as Gt}from"better-call";var Oe=Ie(async()=>({})),ee=Gt({use:[Oe,Ie(async()=>({}))]}),b=Ht({use:[Oe]});var Se=ee(async e=>{if(e.request?.method!=="POST")return;let{body:t,query:r,context:o}=e,i=e.headers?.get("origin")||e.headers?.get("referer")||"",n=t?.callbackURL||r?.callbackURL,d=t?.redirectTo,u=r?.currentURL,s=o.trustedOrigins,a=e.headers?.has("cookie"),c=(f,l)=>l.includes("*")?new RegExp("^"+l.replace(/\*/g,"[^/]+").replace(/\./g,"\\.")+"$").test(f):f.startsWith(l),m=(f,l)=>{if(!f)return;if(!s.some(g=>c(f,g)||f?.startsWith("/")&&l!=="origin"&&!f.includes(":")))throw e.context.logger.error(`Invalid ${l}: ${f}`),e.context.logger.info(`If it's a valid URL, please add ${f} to trustedOrigins in your auth config
`,`Current list of trustedOrigins: ${s}`),new Kt("FORBIDDEN",{message:`Invalid ${l}`})};a&&!e.context.options.advanced?.disableCSRFCheck&&m(i,"origin"),n&&m(n,"callbackURL"),d&&m(d,"redirectURL"),u&&m(u,"currentURL")});import{APIError as E}from"better-call";import{z as U}from"zod";import{TimeSpan as Jt}from"oslo";import{base64url as Yt}from"oslo/encoding";import{HMAC as _e,sha256 as ao}from"oslo/crypto";function me(e,t){let r=new Uint8Array(e),o=new Uint8Array(t);if(r.length!==o.length)return!1;let i=0;for(let n=0;n<r.length;n++)i|=r[n]^o[n];return i===0}async function Qt({value:e,secret:t}){return new _e("SHA-256").sign(new TextEncoder().encode(t),new TextEncoder().encode(e)).then(o=>Buffer.from(o).toString("base64"))}function Wt({value:e,signature:t,secret:r}){return new _e("SHA-256").verify(new TextEncoder().encode(r),Buffer.from(t,"base64"),new TextEncoder().encode(e))}var te={sign:Qt,verify:Wt};var O=class extends Error{constructor(t,r){super(t),this.name="BetterAuthError",this.message=t,this.cause=r,this.stack=""}},Le=class extends O{constructor(t){super(`The package "${t}" is required. Make sure it is installed.`,t)}};var S=(e,t="ms")=>new Date(Date.now()+(t==="sec"?e*1e3:e));var re=Object.create(null),K=e=>globalThis.process?.env||globalThis.Deno?.env.toObject()||globalThis.__env__||(e?re:globalThis),_=new Proxy(re,{get(e,t){return K()[t]??re[t]},has(e,t){let r=K();return t in r||t in re},set(e,t,r){let o=K(!0);return o[t]=r,!0},deleteProperty(e,t){if(!t)return!1;let r=K(!0);return delete r[t],!0},ownKeys(){let e=K(!0);return Object.keys(e)}});function Zt(e){return e?e!=="false":!1}var oe=typeof process<"u"&&process.env&&process.env.NODE_ENV||"",Q=oe==="production",Ce=oe==="dev"||oe==="development",Be=oe==="test"||Zt(_.TEST);function mo(e){let t=new Map;return e.split(", ").forEach(o=>{let i=o.split(";").map(m=>m.trim()),[n,...d]=i,[u,...s]=n.split("="),a=s.join("=");if(!u||a===void 0){console.warn(`Malformed cookie: ${o}`);return}let c={value:a};d.forEach(m=>{let[f,...l]=m.split("="),p=l.join("="),g=f.trim().toLowerCase();switch(g){case"max-age":c["max-age"]=p?parseInt(p.trim(),10):void 0;break;case"expires":c.expires=p?new Date(p.trim()):void 0;break;case"domain":c.domain=p?p.trim():void 0;break;case"path":c.path=p?p.trim():void 0;break;case"secure":c.secure=!0;break;case"httponly":c.httponly=!0;break;case"samesite":c.samesite=p?p.trim().toLowerCase():void 0;break;default:c[g]=p?p.trim():!0;break}}),t.set(u,c)}),t}function ge(e){let r=(e.advanced?.useSecureCookies!==void 0?e.advanced?.useSecureCookies:e.baseURL!==void 0?!!e.baseURL.startsWith("https://"):Q)?"__Secure-":"",o=!!e.advanced?.crossSubDomainCookies?.enabled,i=o?e.advanced?.crossSubDomainCookies?.domain||(e.baseURL?new URL(e.baseURL).hostname:void 0):void 0;if(o&&!i)throw new O("baseURL is required when crossSubdomainCookies are enabled");function n(d,u={}){let s=e.advanced?.cookiePrefix||"better-auth",a=e.advanced?.cookies?.[d]?.name||`${s}.${d}`,c=e.advanced?.cookies?.[d]?.attributes;return{name:`${r}${a}`,attributes:{secure:!!r,sameSite:"lax",path:"/",httpOnly:!0,...o?{domain:i}:{},...e.advanced?.defaultCookieAttributes,...u,...c}}}return n}function De(e){let t=ge(e),r=e.session?.expiresIn||new Jt(7,"d").seconds(),o=t("session_token",{maxAge:r}),i=t("session_data",{maxAge:e.session?.cookieCache?.maxAge||60*5}),n=t("dont_remember");return{sessionToken:{name:o.name,options:o.attributes},sessionData:{name:i.name,options:i.attributes},dontRememberToken:{name:n.name,options:n.attributes}}}async function I(e,t,r,o){let i=e.context.authCookies.sessionToken.options,n=r?void 0:e.context.sessionConfig.expiresIn;await e.setSignedCookie(e.context.authCookies.sessionToken.name,t.session.id,e.context.secret,{...i,maxAge:n,...o}),r&&await e.setSignedCookie(e.context.authCookies.dontRememberToken.name,"true",e.context.secret,e.context.authCookies.dontRememberToken.options),e.context.options.session?.cookieCache?.enabled&&e.setCookie(e.context.authCookies.sessionData.name,JSON.stringify(Yt.encode(new TextEncoder().encode(JSON.stringify({session:t,expiresAt:S(e.context.authCookies.sessionData.options.maxAge||60,"sec").getTime(),signature:await te.sign({value:JSON.stringify(t),secret:e.context.secret})})))),e.context.authCookies.sessionData.options),e.context.options.secondaryStorage&&await e.context.secondaryStorage?.set(t.session.id,JSON.stringify({user:t.user,session:t.session}),t.session.expiresAt.getTime()-Date.now())}function q(e){e.setCookie(e.context.authCookies.sessionToken.name,"",{...e.context.authCookies.sessionToken.options,maxAge:0}),e.setCookie(e.context.authCookies.sessionData.name,"",{...e.context.authCookies.sessionData.options,maxAge:0}),e.setCookie(e.context.authCookies.dontRememberToken.name,"",{...e.context.authCookies.dontRememberToken.options,maxAge:0})}function Ro(e){let t=e.split("; "),r=new Map;return t.forEach(o=>{let[i,n]=o.split("=");r.set(i,n)}),r}import{betterFetch as ir}from"@better-fetch/fetch";import{APIError as sr}from"better-call";import{decodeProtectedHeader as ar,importJWK as dr,jwtVerify as cr}from"jose";import{parseJWT as ur}from"oslo/jwt";import{sha256 as Xt}from"oslo/crypto";import{base64url as er}from"oslo/encoding";async function Ne(e){let t=await Xt(new TextEncoder().encode(e));return er.encode(new Uint8Array(t),{includePadding:!1})}function qe(e){return{tokenType:e.token_type,accessToken:e.access_token,refreshToken:e.refresh_token,accessTokenExpiresAt:e.expires_in?S(e.expires_in,"sec"):void 0,scopes:e?.scope?typeof e.scope=="string"?e.scope.split(" "):e.scope:[],idToken:e.id_token}}async function v({id:e,options:t,authorizationEndpoint:r,state:o,codeVerifier:i,scopes:n,claims:d,redirectURI:u}){let s=new URL(r);if(s.searchParams.set("response_type","code"),s.searchParams.set("client_id",t.clientId),s.searchParams.set("state",o),s.searchParams.set("scope",n.join(" ")),s.searchParams.set("redirect_uri",t.redirectURI||u),i){let a=await Ne(i);s.searchParams.set("code_challenge_method","S256"),s.searchParams.set("code_challenge",a)}if(d){let a=d.reduce((c,m)=>(c[m]=null,c),{});s.searchParams.set("claims",JSON.stringify({id_token:{email:null,email_verified:null,...a}}))}return s}import{betterFetch as tr}from"@better-fetch/fetch";async function R({code:e,codeVerifier:t,redirectURI:r,options:o,tokenEndpoint:i,authentication:n}){let d=new URLSearchParams,u={"content-type":"application/x-www-form-urlencoded",accept:"application/json","user-agent":"better-auth"};if(d.set("grant_type","authorization_code"),d.set("code",e),t&&d.set("code_verifier",t),d.set("redirect_uri",r),n==="basic"){let m=btoa(`${o.clientId}:${o.clientSecret}`);u.authorization=`Basic ${m}`}else d.set("client_id",o.clientId),d.set("client_secret",o.clientSecret);let{data:s,error:a}=await tr(i,{method:"POST",body:d,headers:u});if(a)throw a;return qe(s)}import{generateCodeVerifier as or,generateState as nr}from"oslo/oauth2";import{z as $}from"zod";import{APIError as Fe}from"better-call";function rr(e){try{return new URL(e).pathname!=="/"}catch{throw new O(`Invalid base URL: ${e}. Please provide a valid base URL.`)}}function he(e,t="/api/auth"){return rr(e)?e:(t=t.startsWith("/")?t:`/${t}`,`${e}${t}`)}function W(e,t){if(e)return he(e,t);let r=_.BETTER_AUTH_URL||_.NEXT_PUBLIC_BETTER_AUTH_URL||_.PUBLIC_BETTER_AUTH_URL||_.NUXT_PUBLIC_BETTER_AUTH_URL||_.NUXT_PUBLIC_AUTH_URL||(_.BASE_URL!=="/"?_.BASE_URL:void 0);if(r)return he(r,t);if(typeof window<"u"&&window.location)return he(window.location.origin,t)}function Ve(e){try{return new URL(e).origin}catch{return null}}async function ne(e,t){let r=e.body?.callbackURL||(e.query?.currentURL?Ve(e.query?.currentURL):"")||e.context.options.baseURL;if(!r)throw new Fe("BAD_REQUEST",{message:"callbackURL is required"});let o=or(),i=nr(),n=JSON.stringify({callbackURL:r,codeVerifier:o,errorURL:e.body?.errorCallbackURL||e.query?.currentURL,link:t,expiresAt:Date.now()+10*60*1e3}),d=new Date;d.setMinutes(d.getMinutes()+10);let u=await e.context.internalAdapter.createVerificationValue({value:n,identifier:i,expiresAt:d});if(!u)throw e.context.logger.error("Unable to create verification. Make sure the database adapter is properly working and there is a verification table in the database"),new Fe("INTERNAL_SERVER_ERROR",{message:"Unable to create verification"});return{state:u.identifier,codeVerifier:o}}async function $e(e){let t=e.query.state||e.body.state,r=await e.context.internalAdapter.findVerificationValue(t);if(!r)throw e.context.logger.error("State Mismatch. Verification not found",{state:t}),e.redirect(`${e.context.baseURL}/error?error=please_restart_the_process`);let o=$.object({callbackURL:$.string(),codeVerifier:$.string(),errorURL:$.string().optional(),expiresAt:$.number(),link:$.object({email:$.string(),userId:$.string()}).optional()}).parse(JSON.parse(r.value));if(o.errorURL||(o.errorURL=`${e.context.baseURL}/error`),o.expiresAt<Date.now())throw await e.context.internalAdapter.deleteVerificationValue(r.id),e.context.logger.error("State expired.",{state:t}),e.redirect(`${e.context.baseURL}/error?error=please_restart_the_process`);return await e.context.internalAdapter.deleteVerificationValue(r.id),o}var je=e=>{let t="https://appleid.apple.com/auth/token";return{id:"apple",name:"Apple",createAuthorizationURL({state:r,scopes:o,redirectURI:i}){let n=o||["email","name"];return e.scope&&n.push(...e.scope),new URL(`https://appleid.apple.com/auth/authorize?client_id=${e.clientId}&response_type=code&redirect_uri=${i||e.redirectURI}&scope=${n.join(" ")}&state=${r}&response_mode=form_post`)},validateAuthorizationCode:async({code:r,codeVerifier:o,redirectURI:i})=>R({code:r,codeVerifier:o,redirectURI:e.redirectURI||i,options:e,tokenEndpoint:t}),async verifyIdToken(r,o){if(e.disableIdTokenSignIn)return!1;if(e.verifyIdToken)return e.verifyIdToken(r,o);let i=ar(r),{kid:n,alg:d}=i;if(!n||!d)return!1;let u=await lr(n),{payload:s}=await cr(r,u,{algorithms:[d],issuer:"https://appleid.apple.com",audience:e.clientId,maxTokenAge:"1h"});return["email_verified","is_private_email"].forEach(a=>{s[a]!==void 0&&(s[a]=!!s[a])}),o&&s.nonce!==o?!1:!!s},async getUserInfo(r){if(!r.idToken)return null;let o=ur(r.idToken)?.payload;if(!o)return null;let i=o.user?`${o.user.name.firstName} ${o.user.name.lastName}`:o.email;return{user:{id:o.sub,name:i,emailVerified:!1,email:o.email},data:o}}}},lr=async e=>{let t="https://appleid.apple.com",r="/auth/keys",{data:o}=await ir(`${t}${r}`);if(!o?.keys)throw new sr("BAD_REQUEST",{message:"Keys not found"});let i=o.keys.find(n=>n.kid===e);if(!i)throw new Error(`JWK with kid ${e} not found`);return await dr(i,i.alg)};import{betterFetch as pr}from"@better-fetch/fetch";var ze=e=>({id:"discord",name:"Discord",createAuthorizationURL({state:t,scopes:r,redirectURI:o}){let i=r||["identify","email"];return e.scope&&i.push(...e.scope),new URL(`https://discord.com/api/oauth2/authorize?scope=${i.join("+")}&response_type=code&client_id=${e.clientId}&redirect_uri=${encodeURIComponent(e.redirectURI||o)}&state=${t}`)},validateAuthorizationCode:async({code:t,redirectURI:r})=>R({code:t,redirectURI:e.redirectURI||r,options:e,tokenEndpoint:"https://discord.com/api/oauth2/token"}),async getUserInfo(t){let{data:r,error:o}=await pr("https://discord.com/api/users/@me",{headers:{authorization:`Bearer ${t.accessToken}`}});if(o)return null;if(r.avatar===null){let i=r.discriminator==="0"?Number(BigInt(r.id)>>BigInt(22))%6:parseInt(r.discriminator)%5;r.image_url=`https://cdn.discordapp.com/embed/avatars/${i}.png`}else{let i=r.avatar.startsWith("a_")?"gif":"png";r.image_url=`https://cdn.discordapp.com/avatars/${r.id}/${r.avatar}.${i}`}return{user:{id:r.id,name:r.display_name||r.username||"",email:r.email,emailVerified:r.verified,image:r.image_url},data:r}}});import{betterFetch as fr}from"@better-fetch/fetch";var Me=e=>({id:"facebook",name:"Facebook",async createAuthorizationURL({state:t,scopes:r,redirectURI:o}){let i=r||["email","public_profile"];return e.scope&&i.push(...e.scope),await v({id:"facebook",options:e,authorizationEndpoint:"https://www.facebook.com/v21.0/dialog/oauth",scopes:i,state:t,redirectURI:o})},validateAuthorizationCode:async({code:t,redirectURI:r})=>R({code:t,redirectURI:e.redirectURI||r,options:e,tokenEndpoint:"https://graph.facebook.com/oauth/access_token"}),async getUserInfo(t){let{data:r,error:o}=await fr("https://graph.facebook.com/me?fields=id,name,email,picture",{auth:{type:"Bearer",token:t.accessToken}});return o?null:{user:{id:r.id,name:r.name,email:r.email,image:r.picture.data.url,emailVerified:r.email_verified},data:r}}});import{betterFetch as He}from"@better-fetch/fetch";var Ge=e=>{let t="https://github.com/login/oauth/access_token";return{id:"github",name:"GitHub",createAuthorizationURL({state:r,scopes:o,codeVerifier:i,redirectURI:n}){let d=o||["user:email"];return e.scope&&d.push(...e.scope),v({id:"github",options:e,authorizationEndpoint:"https://github.com/login/oauth/authorize",scopes:d,state:r,redirectURI:n})},validateAuthorizationCode:async({code:r,redirectURI:o})=>R({code:r,redirectURI:e.redirectURI||o,options:e,tokenEndpoint:t}),async getUserInfo(r){let{data:o,error:i}=await He("https://api.github.com/user",{headers:{"User-Agent":"better-auth",authorization:`Bearer ${r.accessToken}`}});if(i)return null;let n=!1;if(!o.email){let{data:d,error:u}=await He("https://api.github.com/user/emails",{headers:{authorization:`Bearer ${r.accessToken}`,"User-Agent":"better-auth"}});u||(o.email=(d.find(s=>s.primary)??d[0])?.email,n=d.find(s=>s.email===o.email)?.verified??!1)}return{user:{id:o.id.toString(),name:o.name||o.login,email:o.email,image:o.avatar_url,emailVerified:n},data:o}}}};import{parseJWT as yr}from"oslo/jwt";import{createConsola as mr}from"consola";var ye=["info","success","warn","error","debug"];function gr(e,t){return ye.indexOf(t)<=ye.indexOf(e)}var hr=mr({formatOptions:{date:!1,colors:!0,compact:!0},defaults:{tag:"Better Auth"}}),ie=e=>{let t=e?.disabled!==!0,r=e?.level??"error",o=(i,n,d=[])=>{if(!(!t||!gr(r,i))){if(!e||typeof e.log!="function"){hr[i]("",n,...d);return}e.log(i==="success"?"info":i,n,d)}};return Object.fromEntries(ye.map(i=>[i,(...[n,...d])=>o(i,n,d)]))},L=ie();import{betterFetch as wr}from"@better-fetch/fetch";var Ke=e=>({id:"google",name:"Google",async createAuthorizationURL({state:t,scopes:r,codeVerifier:o,redirectURI:i}){if(!e.clientId||!e.clientSecret)throw L.error("Client Id and Client Secret is required for Google. Make sure to provide them in the options."),new O("CLIENT_ID_AND_SECRET_REQUIRED");if(!o)throw new O("codeVerifier is required for Google");let n=r||["email","profile","openid"];e.scope&&n.push(...e.scope);let d=await v({id:"google",options:e,authorizationEndpoint:"https://accounts.google.com/o/oauth2/auth",scopes:n,state:t,codeVerifier:o,redirectURI:i});return e.accessType&&d.searchParams.set("access_type",e.accessType),e.prompt&&d.searchParams.set("prompt",e.prompt),d},validateAuthorizationCode:async({code:t,codeVerifier:r,redirectURI:o})=>R({code:t,codeVerifier:r,redirectURI:e.redirectURI||o,options:e,tokenEndpoint:"https://oauth2.googleapis.com/token"}),async verifyIdToken(t,r){if(e.disableIdTokenSignIn)return!1;if(e.verifyIdToken)return e.verifyIdToken(t,r);let o=`https://www.googleapis.com/oauth2/v3/tokeninfo?id_token=${t}`,{data:i}=await wr(o);return i?i.aud===e.clientId&&i.iss==="https://accounts.google.com":!1},async getUserInfo(t){if(!t.idToken)return null;let r=yr(t.idToken)?.payload;return{user:{id:r.sub,name:r.name,email:r.email,image:r.picture,emailVerified:r.email_verified},data:r}}});import{betterFetch as br}from"@better-fetch/fetch";import{parseJWT as Ar}from"oslo/jwt";var Qe=e=>{let t=e.tenantId||"common",r=`https://login.microsoftonline.com/${t}/oauth2/v2.0/authorize`,o=`https://login.microsoftonline.com/${t}/oauth2/v2.0/token`;return{id:"microsoft",name:"Microsoft EntraID",createAuthorizationURL(i){let n=i.scopes||["openid","profile","email","User.Read"];return e.scope&&n.push(...e.scope),v({id:"microsoft",options:e,authorizationEndpoint:r,state:i.state,codeVerifier:i.codeVerifier,scopes:n,redirectURI:i.redirectURI})},validateAuthorizationCode({code:i,codeVerifier:n,redirectURI:d}){return R({code:i,codeVerifier:n,redirectURI:e.redirectURI||d,options:e,tokenEndpoint:o})},async getUserInfo(i){if(!i.idToken)return null;let n=Ar(i.idToken)?.payload,d=e.profilePhotoSize||48;return await br(`https://graph.microsoft.com/v1.0/me/photos/${d}x${d}/$value`,{headers:{Authorization:`Bearer ${i.accessToken}`},async onResponse(u){if(!(e.disableProfilePhoto||!u.response.ok))try{let a=await u.response.clone().arrayBuffer(),c=Buffer.from(a).toString("base64");n.picture=`data:image/jpeg;base64, ${c}`}catch(s){L.error(s&&typeof s=="object"&&"name"in s?s.name:"",s)}}}),{user:{id:n.sub,name:n.name,email:n.email,image:n.picture,emailVerified:!0},data:n}}}};import{betterFetch as kr}from"@better-fetch/fetch";var We=e=>({id:"spotify",name:"Spotify",createAuthorizationURL({state:t,scopes:r,codeVerifier:o,redirectURI:i}){let n=r||["user-read-email"];return e.scope&&n.push(...e.scope),v({id:"spotify",options:e,authorizationEndpoint:"https://accounts.spotify.com/authorize",scopes:n,state:t,codeVerifier:o,redirectURI:i})},validateAuthorizationCode:async({code:t,codeVerifier:r,redirectURI:o})=>R({code:t,codeVerifier:r,redirectURI:e.redirectURI||o,options:e,tokenEndpoint:"https://accounts.spotify.com/api/token"}),async getUserInfo(t){let{data:r,error:o}=await kr("https://api.spotify.com/v1/me",{method:"GET",headers:{Authorization:`Bearer ${t.accessToken}`}});return o?null:{user:{id:r.id,name:r.display_name,email:r.email,image:r.images[0]?.url,emailVerified:!1},data:r}}});function Tn(e){return e.charAt(0).toUpperCase()+e.slice(1)}var z={isAction:!1};import{nanoid as Rr}from"nanoid";var B=e=>Rr(e);import{parseJWT as xr}from"oslo/jwt";var Ze=e=>({id:"twitch",name:"Twitch",createAuthorizationURL({state:t,scopes:r,redirectURI:o}){let i=r||["user:read:email","openid"];return e.scope&&i.push(...e.scope),v({id:"twitch",redirectURI:o,options:e,authorizationEndpoint:"https://id.twitch.tv/oauth2/authorize",scopes:i,state:t,claims:e.claims||["email","email_verified","preferred_username","picture"]})},validateAuthorizationCode:async({code:t,redirectURI:r})=>R({code:t,redirectURI:e.redirectURI||r,options:e,tokenEndpoint:"https://id.twitch.tv/oauth2/token"}),async getUserInfo(t){let r=t.idToken;if(!r)return L.error("No idToken found in token"),null;let o=xr(r)?.payload;return{user:{id:o.sub,name:o.preferred_username,email:o.email,image:o.picture,emailVerified:!1},data:o}}});import{betterFetch as vr}from"@better-fetch/fetch";var Je=e=>({id:"twitter",name:"Twitter",createAuthorizationURL(t){let r=t.scopes||["users.read","tweet.read","offline.access"];return e.scope&&r.push(...e.scope),v({id:"twitter",options:e,authorizationEndpoint:"https://x.com/i/oauth2/authorize",scopes:r,state:t.state,codeVerifier:t.codeVerifier,redirectURI:t.redirectURI})},validateAuthorizationCode:async({code:t,codeVerifier:r,redirectURI:o})=>R({code:t,codeVerifier:r,authentication:"basic",redirectURI:e.redirectURI||o,options:e,tokenEndpoint:"https://api.x.com/2/oauth2/token"}),async getUserInfo(t){let{data:r,error:o}=await vr("https://api.x.com/2/users/me?user.fields=profile_image_url",{method:"GET",headers:{Authorization:`Bearer ${t.accessToken}`}});return o?null:{user:{id:r.data.id,name:r.data.name,email:r.data.email||null,image:r.data.profile_image_url,emailVerified:r.data.verified||!1},data:r}}});import{betterFetch as Ur}from"@better-fetch/fetch";var Ye=e=>{let t="https://api.dropboxapi.com/oauth2/token";return{id:"dropbox",name:"Dropbox",createAuthorizationURL:async({state:r,scopes:o,codeVerifier:i,redirectURI:n})=>{let d=o||["account_info.read"];return e.scope&&d.push(...e.scope),await v({id:"dropbox",options:e,authorizationEndpoint:"https://www.dropbox.com/oauth2/authorize",scopes:d,state:r,redirectURI:n,codeVerifier:i})},validateAuthorizationCode:async({code:r,codeVerifier:o,redirectURI:i})=>await R({code:r,codeVerifier:o,redirectURI:e.redirectURI||i,options:e,tokenEndpoint:t}),async getUserInfo(r){let{data:o,error:i}=await Ur("https://api.dropboxapi.com/2/users/get_current_account",{method:"POST",headers:{Authorization:`Bearer ${r.accessToken}`}});return i?null:{user:{id:o.account_id,name:o.name?.display_name,email:o.email,emailVerified:o.email_verified||!1,image:o.profile_photo_url},data:o}}}};import{betterFetch as Tr}from"@better-fetch/fetch";var Xe=e=>{let t="https://www.linkedin.com/oauth/v2/authorization",r="https://www.linkedin.com/oauth/v2/accessToken";return{id:"linkedin",name:"Linkedin",createAuthorizationURL:async({state:o,scopes:i,redirectURI:n})=>{let d=i||["profile","email","openid"];return e.scope&&d.push(...e.scope),await v({id:"linkedin",options:e,authorizationEndpoint:t,scopes:d,state:o,redirectURI:n})},validateAuthorizationCode:async({code:o,redirectURI:i})=>await R({code:o,redirectURI:e.redirectURI||i,options:e,tokenEndpoint:r}),async getUserInfo(o){let{data:i,error:n}=await Tr("https://api.linkedin.com/v2/userinfo",{method:"GET",headers:{Authorization:`Bearer ${o.accessToken}`}});return n?null:{user:{id:i.sub,name:i.name,email:i.email,emailVerified:i.email_verified||!1,image:i.picture},data:i}}}};import{betterFetch as Er}from"@better-fetch/fetch";var we=(e="")=>e.split("://").map(t=>t.replace(/\/{2,}/g,"/")).join("://"),Pr=e=>{let t=e||"https://gitlab.com";return{authorizationEndpoint:we(`${t}/oauth/authorize`),tokenEndpoint:we(`${t}/oauth/token`),userinfoEndpoint:we(`${t}/api/v4/user`)}},et=e=>{let{authorizationEndpoint:t,tokenEndpoint:r,userinfoEndpoint:o}=Pr(e.issuer),i="gitlab";return{id:i,name:"Gitlab",createAuthorizationURL:async({state:d,scopes:u,codeVerifier:s,redirectURI:a})=>{let c=u||["read_user"];return e.scope&&c.push(...e.scope),await v({id:i,options:e,authorizationEndpoint:t,scopes:c,state:d,redirectURI:a,codeVerifier:s})},validateAuthorizationCode:async({code:d,redirectURI:u,codeVerifier:s})=>R({code:d,redirectURI:e.redirectURI||u,options:e,codeVerifier:s,tokenEndpoint:r}),async getUserInfo(d){let{data:u,error:s}=await Er(o,{headers:{authorization:`Bearer ${d.accessToken}`}});return s||u.state!=="active"||u.locked?null:{user:{id:u.id.toString(),name:u.name??u.username,email:u.email,image:u.avatar_url,emailVerified:!0},data:u}}}};var be={apple:je,discord:ze,facebook:Me,github:Ge,microsoft:Qe,google:Ke,spotify:We,twitch:Ze,twitter:Je,dropbox:Ye,linkedin:Xe,gitlab:et},se=Object.keys(be);import{TimeSpan as Ir}from"oslo";import{createJWT as Or,validateJWT as Sr}from"oslo/jwt";import{z as N}from"zod";import{APIError as de}from"better-call";import{APIError as j}from"better-call";import{z as Z}from"zod";function M(e){try{return JSON.parse(e)}catch{return null}}var Ae=()=>b("/get-session",{method:"GET",query:Z.optional(Z.object({disableCookieCache:Z.boolean().optional()})),requireHeaders:!0},async e=>{try{let t=await e.getSignedCookie(e.context.authCookies.sessionToken.name,e.context.secret);if(!t)return e.json(null);let r=e.getCookie(e.context.authCookies.sessionData.name),o=r?M(Buffer.from(r,"base64").toString()):null;if(o&&!await te.verify({value:JSON.stringify(o.session),signature:o?.signature,secret:e.context.secret}))return q(e),e.json(null);let i=await e.getSignedCookie(e.context.authCookies.dontRememberToken.name,e.context.secret);if(o?.session&&e.context.options.session?.cookieCache?.enabled&&!e.query?.disableCookieCache){let c=o.session;if(o.expiresAt<Date.now()||c.session.expiresAt<new Date){let f=e.context.authCookies.sessionData.name;e.setCookie(f,"",{maxAge:0})}else return e.json(c)}let n=await e.context.internalAdapter.findSession(t);if(!n||n.session.expiresAt<new Date)return q(e),n&&await e.context.internalAdapter.deleteSession(n.session.id),e.json(null);if(i)return e.json(n);let d=e.context.sessionConfig.expiresIn,u=e.context.sessionConfig.updateAge;if(n.session.expiresAt.valueOf()-d*1e3+u*1e3<=Date.now()){let c=await e.context.internalAdapter.updateSession(n.session.id,{expiresAt:S(e.context.sessionConfig.expiresIn,"sec")});if(!c)return q(e),e.json(null,{status:401});let m=(c.expiresAt.valueOf()-Date.now())/1e3;return await I(e,{session:c,user:n.user},!1,{maxAge:m}),e.json({session:c,user:n.user})}return e.json(n)}catch(t){throw e.context.logger.error("INTERNAL_SERVER_ERROR",t),new j("INTERNAL_SERVER_ERROR",{message:"internal server error"})}}),ae=async e=>{if(e.context.session)return e.context.session;let t=await Ae()({...e,_flag:"json",headers:e.headers});return e.context.session=t,t},C=ee(async e=>{let t=await ae(e);if(!t?.session)throw new j("UNAUTHORIZED");return{session:t}}),tt=()=>b("/list-sessions",{method:"GET",use:[C],requireHeaders:!0},async e=>{let r=(await e.context.internalAdapter.listSessions(e.context.session.user.id)).filter(o=>o.expiresAt>new Date);return e.json(r)}),rt=b("/revoke-session",{method:"POST",body:Z.object({id:Z.string()}),use:[C],requireHeaders:!0},async e=>{let t=e.body.id,r=await e.context.internalAdapter.findSession(t);if(!r)throw new j("BAD_REQUEST",{message:"Session not found"});if(r.session.userId!==e.context.session.user.id)throw new j("UNAUTHORIZED");try{await e.context.internalAdapter.deleteSession(t)}catch(o){throw e.context.logger.error(o&&typeof o=="object"&&"name"in o?o.name:"",o),new j("INTERNAL_SERVER_ERROR")}return e.json({status:!0})}),ot=b("/revoke-sessions",{method:"POST",use:[C],requireHeaders:!0},async e=>{try{await e.context.internalAdapter.deleteSessions(e.context.session.user.id)}catch(t){throw e.context.logger.error(t&&typeof t=="object"&&"name"in t?t.name:"",t),new j("INTERNAL_SERVER_ERROR")}return e.json({status:!0})}),nt=b("/revoke-other-sessions",{method:"POST",requireHeaders:!0,use:[C]},async e=>{let t=e.context.session;if(!t.user)throw new j("UNAUTHORIZED");let i=(await e.context.internalAdapter.listSessions(t.user.id)).filter(n=>n.expiresAt>new Date).filter(n=>n.id!==e.context.session.session.id);return await Promise.all(i.map(n=>e.context.internalAdapter.deleteSession(n.id))),e.json({status:!0})});async function V(e,t,r){return await Or("HS256",Buffer.from(e),{email:t.toLowerCase(),updateTo:r},{expiresIn:new Ir(1,"h"),issuer:"better-auth",subject:"verify-email",audiences:[t],includeIssuedTimestamp:!0})}var it=b("/send-verification-email",{method:"POST",query:N.object({currentURL:N.string().optional()}).optional(),body:N.object({email:N.string().email(),callbackURL:N.string().optional()})},async e=>{if(!e.context.options.emailVerification?.sendVerificationEmail)throw e.context.logger.error("Verification email isn't enabled."),new de("BAD_REQUEST",{message:"Verification email isn't enabled"});let{email:t}=e.body,r=await e.context.internalAdapter.findUserByEmail(t);if(!r)throw new de("BAD_REQUEST",{message:"User not found"});let o=await V(e.context.secret,t),i=`${e.context.baseURL}/verify-email?token=${o}&callbackURL=${e.body.callbackURL||e.query?.currentURL||"/"}`;return await e.context.options.emailVerification.sendVerificationEmail({user:r.user,url:i,token:o},e.request),e.json({status:!0})}),st=b("/verify-email",{method:"GET",query:N.object({token:N.string(),callbackURL:N.string().optional()})},async e=>{function t(u){throw e.query.callbackURL?e.redirect(`${e.query.callbackURL}?error=${u}`):new de("UNAUTHORIZED",{message:u})}let{token:r}=e.query,o;try{o=await Sr("HS256",Buffer.from(e.context.secret),r)}catch(u){return e.context.logger.error("Failed to verify email",u),t("invalid_token")}let n=N.object({email:N.string().email(),updateTo:N.string().optional()}).parse(o.payload),d=await e.context.internalAdapter.findUserByEmail(n.email);if(!d)return t("user_not_found");if(n.updateTo){let u=await ae(e);if(!u){if(e.query.callbackURL)throw e.redirect(`${e.query.callbackURL}?error=unauthorized`);return t("unauthorized")}if(u.user.email!==n.email){if(e.query.callbackURL)throw e.redirect(`${e.query.callbackURL}?error=unauthorized`);return t("unauthorized")}let s=await e.context.internalAdapter.updateUserByEmail(n.email,{email:n.updateTo});if(await e.context.options.emailVerification?.sendVerificationEmail?.({user:s,url:`${e.context.baseURL}/verify-email?token=${r}`,token:r},e.request),e.query.callbackURL)throw e.redirect(e.query.callbackURL);return e.json({user:s,status:!0})}if(await e.context.internalAdapter.updateUserByEmail(n.email,{emailVerified:!0}),e.context.options.emailVerification?.autoSignInAfterVerification&&!await ae(e)){let s=await e.context.internalAdapter.createSession(d.user.id,e.request);if(!s)throw new de("INTERNAL_SERVER_ERROR",{message:"Failed to create session"});await I(e,{session:s,user:d.user})}if(e.query.callbackURL)throw e.redirect(e.query.callbackURL);return e.json({user:null,status:!0})});async function ce(e,{userInfo:t,account:r,callbackURL:o}){let i=await e.context.internalAdapter.findUserByEmail(t.email.toLowerCase(),{includeAccounts:!0}).catch(u=>{throw L.error(`Better auth was unable to query your database.
Error: `,u),e.redirect(`${e.context.baseURL}/error?error=internal_server_error`)}),n=i?.user;if(i){let u=i.accounts.find(s=>s.providerId===r.providerId);if(u)await e.context.internalAdapter.updateAccount(u.id,{accessToken:r.accessToken,idToken:r.idToken,refreshToken:r.refreshToken,expiresAt:r.expiresAt});else{if(!e.context.options.account?.accountLinking?.trustedProviders?.includes(r.providerId)&&!t.emailVerified||e.context.options.account?.accountLinking?.enabled===!1)return Ce&&L.warn(`User already exist but account isn't linked to ${r.providerId}. To read more about how account linking works in Better Auth see https://www.better-auth.com/docs/concepts/users-accounts#account-linking.`),{error:"account not linked",data:null};try{await e.context.internalAdapter.linkAccount({providerId:r.providerId,accountId:t.id.toString(),id:e.context.uuid(),userId:i.user.id,accessToken:r.accessToken,idToken:r.idToken,refreshToken:r.refreshToken,expiresAt:r.expiresAt})}catch(c){return L.error("Unable to link account",c),{error:"unable to link account",data:null}}}}else try{let u=t.emailVerified||!1;if(n=await e.context.internalAdapter.createOAuthUser({...t,id:e.context.uuid(),emailVerified:u,email:t.email.toLowerCase()},{accessToken:r.accessToken,idToken:r.idToken,refreshToken:r.refreshToken,expiresAt:r.expiresAt,providerId:r.providerId,accountId:t.id.toString()}).then(s=>s?.user),!u&&n&&e.context.options.emailVerification?.sendOnSignUp){let s=await V(e.context.secret,n.email),a=`${e.context.baseURL}/verify-email?token=${s}&callbackURL=${o}`;await e.context.options.emailVerification?.sendVerificationEmail?.({user:n,url:a,token:s},e.request)}}catch(u){return L.error("Unable to create user",u),{error:"unable to create user",data:null}}if(!n)return{error:"unable to create user",data:null};let d=await e.context.internalAdapter.createSession(n.id,e.request);return d?{data:{session:d,user:n},error:null}:{error:"unable to create session",data:null}}var at=b("/sign-in/social",{method:"POST",query:U.object({currentURL:U.string().optional()}).optional(),body:U.object({callbackURL:U.string().optional(),errorCallbackURL:U.string().optional(),provider:U.enum(se),disableRedirect:U.boolean().optional(),idToken:U.optional(U.object({token:U.string(),nonce:U.string().optional(),accessToken:U.string().optional(),refreshToken:U.string().optional(),expiresAt:U.number().optional()}))})},async e=>{let t=e.context.socialProviders.find(n=>n.id===e.body.provider);if(!t)throw e.context.logger.error("Provider not found. Make sure to add the provider in your auth config",{provider:e.body.provider}),new E("NOT_FOUND",{message:"Provider not found"});if(e.body.idToken){if(!t.verifyIdToken)throw e.context.logger.error("Provider does not support id token verification",{provider:e.body.provider}),new E("NOT_FOUND",{message:"Provider does not support id token verification"});let{token:n,nonce:d}=e.body.idToken;if(!await t.verifyIdToken(n,d))throw e.context.logger.error("Invalid id token",{provider:e.body.provider}),new E("UNAUTHORIZED",{message:"Invalid id token"});let s=await t.getUserInfo({idToken:n,accessToken:e.body.idToken.accessToken,refreshToken:e.body.idToken.refreshToken});if(!s||!s?.user)throw e.context.logger.error("Failed to get user info",{provider:e.body.provider}),new E("UNAUTHORIZED",{message:"Failed to get user info"});if(!s.user.email)throw e.context.logger.error("User email not found",{provider:e.body.provider}),new E("UNAUTHORIZED",{message:"User email not found"});let a=await ce(e,{userInfo:{email:s.user.email,id:s.user.id,name:s.user.name||"",image:s.user.image,emailVerified:s.user.emailVerified||!1},account:{providerId:t.id,accountId:s.user.id,accessToken:e.body.idToken.accessToken}});if(a.error)throw new E("UNAUTHORIZED",{message:a.error});return await I(e,a.data),e.json({session:a.data.session,user:a.data.user,url:`${e.body.callbackURL||e.query?.currentURL||e.context.options.baseURL}`,redirect:!0})}let{codeVerifier:r,state:o}=await ne(e),i=await t.createAuthorizationURL({state:o,codeVerifier:r,redirectURI:`${e.context.baseURL}/callback/${t.id}`});return e.json({url:i.toString(),redirect:!e.body.disableRedirect})}),dt=b("/sign-in/email",{method:"POST",body:U.object({email:U.string(),password:U.string(),callbackURL:U.string().optional(),rememberMe:U.boolean().default(!0).optional()})},async e=>{if(!e.context.options?.emailAndPassword?.enabled)throw e.context.logger.error("Email and password is not enabled. Make sure to enable it in the options on you `auth.ts` file. Check `https://better-auth.com/docs/authentication/email-password` for more!"),new E("BAD_REQUEST",{message:"Email and password is not enabled"});let{email:t,password:r}=e.body;if(!U.string().email().safeParse(t).success)throw new E("BAD_REQUEST",{message:"Invalid email"});let i=await e.context.internalAdapter.findUserByEmail(t,{includeAccounts:!0});if(!i)throw await e.context.password.hash(r),e.context.logger.error("User not found",{email:t}),new E("UNAUTHORIZED",{message:"Invalid email or password"});let n=i.accounts.find(a=>a.providerId==="credential");if(!n)throw e.context.logger.error("Credential account not found",{email:t}),new E("UNAUTHORIZED",{message:"Invalid email or password"});let d=n?.password;if(!d)throw e.context.logger.error("Password not found",{email:t}),new E("UNAUTHORIZED",{message:"Unexpected error"});if(!await e.context.password.verify(d,r))throw e.context.logger.error("Invalid password"),new E("UNAUTHORIZED",{message:"Invalid email or password"});if(e.context.options?.emailAndPassword?.requireEmailVerification&&!i.user.emailVerified){if(!e.context.options?.emailVerification?.sendVerificationEmail)throw e.context.logger.error("Email verification is required but no email verification handler is provided"),new E("INTERNAL_SERVER_ERROR",{message:"Email is not verified."});let a=await V(e.context.secret,i.user.email),c=`${e.context.baseURL}/verify-email?token=${a}&callbackURL=${e.body.callbackURL||"/"}`;throw await e.context.options.emailVerification.sendVerificationEmail({user:i.user,url:c,token:a},e.request),e.context.logger.error("Email not verified",{email:t}),new E("FORBIDDEN",{message:"Email is not verified. Check your email for a verification link"})}let s=await e.context.internalAdapter.createSession(i.user.id,e.headers,e.body.rememberMe===!1);if(!s)throw e.context.logger.error("Failed to create session"),new E("UNAUTHORIZED",{message:"Failed to create session"});return await I(e,{session:s,user:i.user},e.body.rememberMe===!1),e.json({user:i.user,session:s,redirect:!!e.body.callbackURL,url:e.body.callbackURL})});import{z as J}from"zod";var ue=J.object({code:J.string().optional(),error:J.string().optional(),errorMessage:J.string().optional(),state:J.string().optional()}),ct=b("/callback/:id",{method:["GET","POST"],body:ue.optional(),query:ue.optional(),metadata:z},async e=>{let t;try{if(e.method==="GET")t=ue.parse(e.query);else if(e.method==="POST")t=ue.parse(e.body);else throw new Error("Unsupported method")}catch(w){throw e.context.logger.error("INVALID_CALLBACK_REQUEST",w),e.redirect(`${e.context.baseURL}/error?error=invalid_callback_request`)}let{code:r,error:o,state:i}=t;if(!i)throw e.context.logger.error("State not found"),e.redirect(`${e.context.baseURL}/error?error=state_not_found`);if(!r)throw e.context.logger.error("Code not found"),e.redirect(`${e.context.baseURL}/error?error=${o||"no_code"}`);let n=e.context.socialProviders.find(w=>w.id===e.params.id);if(!n)throw e.context.logger.error("Oauth provider with id",e.params.id,"not found"),e.redirect(`${e.context.baseURL}/error?error=oauth_provider_not_found`);let{codeVerifier:d,callbackURL:u,link:s,errorURL:a}=await $e(e),c;try{c=await n.validateAuthorizationCode({code:r,codeVerifier:d,redirectURI:`${e.context.baseURL}/callback/${n.id}`})}catch(w){throw e.context.logger.error("",w),e.redirect(`${e.context.baseURL}/error?error=please_restart_the_process`)}let m=await n.getUserInfo(c).then(w=>w?.user),l={id:B(),...m};function p(w){let x=a||u||`${e.context.baseURL}/error`;throw x.includes("?")?x=`${x}&error=${w}`:x=`${x}?error=${w}`,e.redirect(x)}if(!m)return e.context.logger.error("Unable to get user info"),p("unable_to_get_user_info");if(!l.email)return e.context.logger.error("Provider did not return email. This could be due to misconfiguration in the provider settings."),p("email_not_found");if(!u)throw e.context.logger.error("No callback URL found"),e.redirect(`${e.context.baseURL}/error?error=please_restart_the_process`);if(s){if(s.email!==l.email.toLowerCase())return p("email_doesn't_match");if(!await e.context.internalAdapter.createAccount({userId:s.userId,providerId:n.id,accountId:m.id}))return p("unable_to_link_account");let x;try{x=new URL(u).toString()}catch{x=u}throw e.redirect(x)}let g=await ce(e,{userInfo:{email:l.email,id:l.id,name:l.name||"",image:l.image,emailVerified:l.emailVerified||!1},account:{providerId:n.id,accountId:m.id,accessToken:c.accessToken,refreshToken:c.refreshToken,expiresAt:c.accessTokenExpiresAt},callbackURL:u});if(g.error)return e.context.logger.error(g.error.split(" ").join("_")),p(g.error.split(" ").join("_"));let{session:y,user:h}=g.data;await I(e,{session:y,user:h});let A;try{A=new URL(u).toString()}catch{A=u}throw e.redirect(A)});import"zod";import{APIError as _r}from"better-call";var ut=b("/sign-out",{method:"POST",requireHeaders:!0},async e=>{let t=await e.getSignedCookie(e.context.authCookies.sessionToken.name,e.context.secret);if(!t)throw q(e),new _r("BAD_REQUEST",{message:"Session not found"});return await e.context.internalAdapter.deleteSession(t),q(e),e.json({success:!0})});import{z as D}from"zod";import{APIError as ke}from"better-call";function lt(e,t,r){let o=t?new URL(t,e.baseURL):new URL(`${e.baseURL}/error`);return r&&Object.entries(r).forEach(([i,n])=>o.searchParams.set(i,n)),o.href}function Lr(e,t,r){let o=new URL(t,e.baseURL);return r&&Object.entries(r).forEach(([i,n])=>o.searchParams.set(i,n)),o.href}var pt=b("/forget-password",{method:"POST",body:D.object({email:D.string().email(),redirectTo:D.string()})},async e=>{if(!e.context.options.emailAndPassword?.sendResetPassword)throw e.context.logger.error("Reset password isn't enabled.Please pass an emailAndPassword.sendResetPasswordToken function in your auth config!"),new ke("BAD_REQUEST",{message:"Reset password isn't enabled"});let{email:t,redirectTo:r}=e.body,o=await e.context.internalAdapter.findUserByEmail(t,{includeAccounts:!0});if(!o)return e.context.logger.error("Reset Password: User not found",{email:t}),e.json({status:!1},{body:{status:!0}});let i=60*60*1,n=S(e.context.options.emailAndPassword.resetPasswordTokenExpiresIn||i,"sec"),d=e.context.uuid();await e.context.internalAdapter.createVerificationValue({value:o.user.id,identifier:`reset-password:${d}`,expiresAt:n});let u=`${e.context.baseURL}/reset-password/${d}?callbackURL=${r}`;return await e.context.options.emailAndPassword.sendResetPassword({user:o.user,url:u,token:d},e.request),e.json({status:!0})}),ft=b("/reset-password/:token",{method:"GET",query:D.object({callbackURL:D.string()})},async e=>{let{token:t}=e.params,{callbackURL:r}=e.query;if(!t||!r)throw e.redirect(lt(e.context,r,{error:"INVALID_TOKEN"}));let o=await e.context.internalAdapter.findVerificationValue(`reset-password:${t}`);throw!o||o.expiresAt<new Date?e.redirect(lt(e.context,r,{error:"INVALID_TOKEN"})):e.redirect(Lr(e.context,r,{token:t}))}),mt=b("/reset-password",{query:D.optional(D.object({token:D.string().optional(),currentURL:D.string().optional()})),method:"POST",body:D.object({newPassword:D.string(),token:D.string().optional()})},async e=>{let t=e.body.token||e.query?.token||(e.query?.currentURL?new URL(e.query.currentURL).searchParams.get("token"):"");if(!t)throw new ke("BAD_REQUEST",{message:"Token not found"});let{newPassword:r}=e.body,o=`reset-password:${t}`,i=await e.context.internalAdapter.findVerificationValue(o);if(!i||i.expiresAt<new Date)throw new ke("BAD_REQUEST",{message:"Invalid token"});await e.context.internalAdapter.deleteVerificationValue(i.id);let n=i.value,d=await e.context.password.hash(r);return(await e.context.internalAdapter.findAccounts(n)).find(a=>a.providerId==="credential")?(await e.context.internalAdapter.updatePassword(n,d),e.json({status:!0})):(await e.context.internalAdapter.createAccount({userId:n,providerId:"credential",password:d,accountId:e.context.uuid()}),e.json({status:!0}))});import{z as T}from"zod";import{APIError as P}from"better-call";import{z as k}from"zod";var ks=k.object({id:k.string(),providerId:k.string(),accountId:k.string(),userId:k.string(),accessToken:k.string().nullish(),refreshToken:k.string().nullish(),idToken:k.string().nullish(),expiresAt:k.date().nullish(),password:k.string().nullish()}),Rs=k.object({id:k.string(),email:k.string().transform(e=>e.toLowerCase()),emailVerified:k.boolean().default(!1),name:k.string(),image:k.string().nullish(),createdAt:k.date().default(new Date),updatedAt:k.date().default(new Date)}),xs=k.object({id:k.string(),userId:k.string(),expiresAt:k.date(),ipAddress:k.string().nullish(),userAgent:k.string().nullish()}),vs=k.object({id:k.string(),value:k.string(),createdAt:k.date(),expiresAt:k.date(),identifier:k.string()});function gt(e,t){let r=t.fields,o={};for(let i in e){let n=r[i];if(!n){o[i]=e[i];continue}n.returned!==!1&&(o[i]=e[i])}return o}function Re(e,t){let r={...t==="user"?e.user?.additionalFields:{},...t==="session"?e.session?.additionalFields:{}};for(let o of e.plugins||[])o.schema&&o.schema[t]&&(r={...r,...o.schema[t].fields});return r}function xe(e,t){let r=Re(e,"user");return gt(t,{fields:r})}function le(e,t){let r=Re(e,"session");return gt(t,{fields:r})}function Cr(e,t){let r=t.action||"create",o=t.fields,i={};for(let n in o){if(n in e){if(o[n].input===!1){if(o[n].defaultValue){i[n]=o[n].defaultValue;continue}continue}i[n]=e[n];continue}if(o[n].defaultValue&&r==="create"){i[n]=o[n].defaultValue;continue}}return i}function pe(e,t,r){let o=Re(e,"user");return Cr(t||{},{fields:o,action:r})}var ht=()=>b("/update-user",{method:"POST",body:T.record(T.string(),T.any()),use:[C]},async e=>{let t=e.body;if(t.email)throw new P("BAD_REQUEST",{message:"You can't update email"});let{name:r,image:o,...i}=t,n=e.context.session;if(!o&&!r&&Object.keys(i).length===0)return e.json({user:n.user});let d=pe(e.context.options,i,"update"),u=await e.context.internalAdapter.updateUserByEmail(n.user.email,{name:r,image:o,...d});return await I(e,{session:n.session,user:u}),e.json({user:u})}),yt=b("/change-password",{method:"POST",body:T.object({newPassword:T.string(),currentPassword:T.string(),revokeOtherSessions:T.boolean().optional()}),use:[C]},async e=>{let{newPassword:t,currentPassword:r,revokeOtherSessions:o}=e.body,i=e.context.session,n=e.context.password.config.minPasswordLength;if(t.length<n)throw e.context.logger.error("Password is too short"),new P("BAD_REQUEST",{message:"Password is too short"});let d=e.context.password.config.maxPasswordLength;if(t.length>d)throw e.context.logger.error("Password is too long"),new P("BAD_REQUEST",{message:"Password too long"});let s=(await e.context.internalAdapter.findAccounts(i.user.id)).find(m=>m.providerId==="credential"&&m.password);if(!s||!s.password)throw new P("BAD_REQUEST",{message:"User does not have a password"});let a=await e.context.password.hash(t);if(!await e.context.password.verify(s.password,r))throw new P("BAD_REQUEST",{message:"Incorrect password"});if(await e.context.internalAdapter.updateAccount(s.id,{password:a}),o){await e.context.internalAdapter.deleteSessions(i.user.id);let m=await e.context.internalAdapter.createSession(i.user.id,e.headers);if(!m)throw new P("INTERNAL_SERVER_ERROR",{message:"Unable to create session"});await I(e,{session:m,user:i.user})}return e.json(i.user)}),wt=b("/set-password",{method:"POST",body:T.object({newPassword:T.string()}),metadata:{SERVER_ONLY:!0},use:[C]},async e=>{let{newPassword:t}=e.body,r=e.context.session,o=e.context.password.config.minPasswordLength;if(t.length<o)throw e.context.logger.error("Password is too short"),new P("BAD_REQUEST",{message:"Password is too short"});let i=e.context.password.config.maxPasswordLength;if(t.length>i)throw e.context.logger.error("Password is too long"),new P("BAD_REQUEST",{message:"Password too long"});let d=(await e.context.internalAdapter.findAccounts(r.user.id)).find(s=>s.providerId==="credential"&&s.password),u=await e.context.password.hash(t);if(!d)return await e.context.internalAdapter.linkAccount({userId:r.user.id,providerId:"credential",accountId:r.user.id,password:u}),e.json(r.user);throw new P("BAD_REQUEST",{message:"user already has a password"})}),bt=b("/delete-user",{method:"POST",body:T.object({password:T.string()}),use:[C]},async e=>{let{password:t}=e.body,r=e.context.session,i=(await e.context.internalAdapter.findAccounts(r.user.id)).find(d=>d.providerId==="credential"&&d.password);if(!i||!i.password)throw new P("BAD_REQUEST",{message:"User does not have a password"});if(!await e.context.password.verify(i.password,t))throw new P("BAD_REQUEST",{message:"Incorrect password"});return await e.context.internalAdapter.deleteUser(r.user.id),await e.context.internalAdapter.deleteSessions(r.user.id),q(e),e.json(null)}),At=b("/change-email",{method:"POST",query:T.object({currentURL:T.string().optional()}).optional(),body:T.object({newEmail:T.string().email(),callbackURL:T.string().optional()}),use:[C]},async e=>{if(!e.context.options.user?.changeEmail?.enabled)throw e.context.logger.error("Change email is disabled."),new P("BAD_REQUEST",{message:"Change email is disabled"});if(e.body.newEmail===e.context.session.user.email)throw e.context.logger.error("Email is the same"),new P("BAD_REQUEST",{message:"Email is the same"});if(await e.context.internalAdapter.findUserByEmail(e.body.newEmail))throw e.context.logger.error("Email already exists"),new P("BAD_REQUEST",{message:"Couldn't update your email"});if(e.context.session.user.emailVerified!==!0){let i=await e.context.internalAdapter.updateUserByEmail(e.context.session.user.email,{email:e.body.newEmail});return e.json({user:i,status:!0})}if(!e.context.options.user.changeEmail.sendChangeEmailVerification)throw e.context.logger.error("Verification email isn't enabled."),new P("BAD_REQUEST",{message:"Verification email isn't enabled"});let r=await V(e.context.secret,e.context.session.user.email,e.body.newEmail),o=`${e.context.baseURL}/verify-email?token=${r}&callbackURL=${e.body.callbackURL||e.query?.currentURL||"/"}`;return await e.context.options.user.changeEmail.sendChangeEmailVerification({user:e.context.session.user,newEmail:e.body.newEmail,url:o,token:r},e.request),e.json({user:null,status:!0})});var Br=(e="Unknown")=>`<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Authentication Error</title>
    <style>
        :root {
            --bg-color: #f8f9fa;
            --text-color: #212529;
            --accent-color: #000000;
            --error-color: #dc3545;
            --border-color: #e9ecef;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            line-height: 1.5;
        }
        .error-container {
            background-color: #ffffff;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
            padding: 2.5rem;
            text-align: center;
            max-width: 90%;
            width: 400px;
        }
        h1 {
            color: var(--error-color);
            font-size: 1.75rem;
            margin-bottom: 1rem;
            font-weight: 600;
        }
        p {
            margin-bottom: 1.5rem;
            color: #495057;
        }
        .btn {
            background-color: var(--accent-color);
            color: #ffffff;
            text-decoration: none;
            padding: 0.75rem 1.5rem;
            border-radius: 6px;
            transition: all 0.3s ease;
            display: inline-block;
            font-weight: 500;
            border: 2px solid var(--accent-color);
        }
        .btn:hover {
            background-color: #131721;
        }
        .error-code {
            font-size: 0.875rem;
            color: #6c757d;
            margin-top: 1.5rem;
            padding-top: 1.5rem;
            border-top: 1px solid var(--border-color);
        }
        .icon {
            font-size: 3rem;
            margin-bottom: 1rem;
        }
    </style>
</head>
<body>
    <div class="error-container">
        <div class="icon">\u26A0\uFE0F</div>
        <h1>Better Auth Error</h1>
        <p>We encountered an issue while processing your request. Please try again or contact the application owner if the problem persists.</p>
        <a href="/" id="returnLink" class="btn">Return to Application</a>
        <div class="error-code">Error Code: <span id="errorCode">${e}</span></div>
    </div>
</body>
</html>`,kt=b("/error",{method:"GET",metadata:z},async e=>{let t=new URL(e.request?.url||"").searchParams.get("error")||"Unknown";return new Response(Br(t),{headers:{"Content-Type":"text/html"}})});var Rt=b("/ok",{method:"GET",metadata:z},async e=>e.json({ok:!0}));import{z as H}from"zod";import{APIError as F}from"better-call";var xt=()=>b("/sign-up/email",{method:"POST",query:H.object({currentURL:H.string().optional()}).optional(),body:H.record(H.string(),H.any())},async e=>{if(!e.context.options.emailAndPassword?.enabled)throw new F("BAD_REQUEST",{message:"Email and password sign up is not enabled"});let t=e.body,{name:r,email:o,password:i,image:n,callbackURL:d,...u}=t;if(!H.string().email().safeParse(o).success)throw new F("BAD_REQUEST",{message:"Invalid email"});let a=e.context.password.config.minPasswordLength;if(i.length<a)throw e.context.logger.error("Password is too short"),new F("BAD_REQUEST",{message:"Password is too short"});let c=e.context.password.config.maxPasswordLength;if(i.length>c)throw e.context.logger.error("Password is too long"),new F("BAD_REQUEST",{message:"Password is too long"});if((await e.context.internalAdapter.findUserByEmail(o))?.user)throw e.context.logger.info(`Sign-up attempt for existing email: ${o}`),new F("UNPROCESSABLE_ENTITY",{message:"User with this email already exists"});let f=pe(e.context.options,u),l;try{if(l=await e.context.internalAdapter.createUser({email:o.toLowerCase(),name:r,image:n,...f,emailVerified:!1}),!l)throw new F("BAD_REQUEST",{message:"Failed to create user"})}catch(y){throw e.context.logger.error("Failed to create user",y),new F("UNPROCESSABLE_ENTITY",{message:"Failed to create user",details:y})}if(!l)throw new F("UNPROCESSABLE_ENTITY",{message:"Failed to create user"});let p=await e.context.password.hash(i);if(await e.context.internalAdapter.linkAccount({userId:l.id,providerId:"credential",accountId:l.id,password:p,expiresAt:S(60*60*24*30,"sec")}),e.context.options.emailVerification?.sendOnSignUp){let y=await V(e.context.secret,l.email),h=`${e.context.baseURL}/verify-email?token=${y}&callbackURL=${t.callbackURL||e.query?.currentURL||"/"}`;await e.context.options.emailVerification?.sendVerificationEmail?.({user:l,url:h,token:y},e.request)}if(!e.context.options.emailAndPassword.autoSignIn||e.context.options.emailAndPassword.requireEmailVerification)return e.json({user:l,session:null});let g=await e.context.internalAdapter.createSession(l.id,e.request);if(!g)throw new F("BAD_REQUEST",{message:"Failed to create session"});return await I(e,{session:g,user:l}),e.json({user:l,session:g})});import{z as Y}from"zod";import{APIError as vt}from"better-call";var Ut=b("/list-accounts",{method:"GET",use:[C]},async e=>{let t=e.context.session,r=await e.context.internalAdapter.findAccounts(t.user.id);return e.json(r.map(o=>({id:o.id,provider:o.providerId})))}),Tt=b("/link-social",{method:"POST",requireHeaders:!0,query:Y.object({currentURL:Y.string().optional()}).optional(),body:Y.object({callbackURL:Y.string().optional(),provider:Y.enum(se)}),use:[C]},async e=>{let t=e.context.session;if((await e.context.internalAdapter.findAccounts(t.user.id)).find(u=>u.providerId===e.body.provider))throw new vt("BAD_REQUEST",{message:"Social Account is already linked."});let i=e.context.socialProviders.find(u=>u.id===e.body.provider);if(!i)throw e.context.logger.error("Provider not found. Make sure to add the provider in your auth config",{provider:e.body.provider}),new vt("NOT_FOUND",{message:"Provider not found"});let n=await ne(e,{userId:t.user.id,email:t.user.email}),d=await i.createAuthorizationURL({state:n.state,codeVerifier:n.codeVerifier,redirectURI:`${e.context.baseURL}/callback/${i.id}`});return e.json({url:d.toString(),redirect:!0})});function fe(e,t){if(t.advanced?.ipAddress?.disableIpTracking)return null;let r="127.0.0.1";if(Be)return r;let i=t.advanced?.ipAddress?.ipAddressHeaders||["x-client-ip","x-forwarded-for","cf-connecting-ip","fastly-client-ip","x-real-ip","x-cluster-client-ip","x-forwarded","forwarded-for","forwarded"],n=e instanceof Request?e.headers:e;for(let d of i){let u=n.get(d);if(typeof u=="string"){let s=u.split(",")[0].trim();if(s)return s}}return null}function Dr(e,t,r){let o=Date.now(),i=t*1e3;return o-r.lastRequest<i&&r.count>=e}function Nr(e){return new Response(JSON.stringify({message:"Too many requests. Please try again later."}),{status:429,statusText:"Too Many Requests",headers:{"X-Retry-After":e.toString()}})}function qr(e,t){let r=Date.now(),o=t*1e3;return Math.ceil((e+o-r)/1e3)}function Vr(e,t){let r="rateLimit",o=e.adapter;return{get:async i=>await o.findOne({model:r,where:[{field:"key",value:i}]}),set:async(i,n,d)=>{try{d?await o.update({model:t??"rateLimit",where:[{field:"key",value:i}],update:{count:n.count,lastRequest:n.lastRequest}}):await o.create({model:t??"rateLimit",data:{key:i,count:n.count,lastRequest:n.lastRequest}})}catch(u){e.logger.error("Error setting rate limit",u)}}}}var Et=new Map;function Fr(e){return e.rateLimit.storage==="secondary-storage"?{get:async r=>{let o=await e.options.secondaryStorage?.get(r);return o?JSON.parse(o):void 0},set:async(r,o)=>{await e.options.secondaryStorage?.set?.(r,JSON.stringify(o))}}:e.rateLimit.storage==="memory"?{async get(r){return Et.get(r)},async set(r,o,i){Et.set(r,o)}}:Vr(e,e.rateLimit.modelName)}async function Pt(e,t){if(!t.rateLimit.enabled)return;let r=t.baseURL,o=e.url.replace(r,""),i=t.rateLimit.window,n=t.rateLimit.max,d=fe(e,t.options)+o,s=$r().find(f=>f.pathMatcher(o));s&&(i=s.window,n=s.max);for(let f of t.options.plugins||[])if(f.rateLimit){let l=f.rateLimit.find(p=>p.pathMatcher(o));if(l){i=l.window,n=l.max;break}}if(t.rateLimit.customRules){let f=t.rateLimit.customRules[o];f&&(i=f.window,n=f.max)}let a=Fr(t),c=await a.get(d),m=Date.now();if(!c)await a.set(d,{key:d,count:1,lastRequest:m});else{let f=m-c.lastRequest;if(Dr(n,i,c)){let l=qr(c.lastRequest,i);return Nr(l)}else f>i*1e3?await a.set(d,{...c,count:1,lastRequest:m}):await a.set(d,{...c,count:c.count+1,lastRequest:m})}}function $r(){return[{pathMatcher(t){return t.startsWith("/sign-in")||t.startsWith("/sign-up")||t.startsWith("/change-password")||t.startsWith("/change-email")},window:10,max:3}]}import{APIError as Na}from"better-call";function Ue(e,t){let r=t.plugins?.reduce((u,s)=>({...u,...s.endpoints}),{}),o=t.plugins?.map(u=>u.middlewares?.map(s=>{let a=async c=>s.middleware({...c,context:{...e,...c.context}});return a.path=s.path,a.options=s.middleware.options,a.headers=s.middleware.headers,{path:s.path,middleware:a}})).filter(u=>u!==void 0).flat()||[],n={...{signInSocial:at,callbackOAuth:ct,getSession:Ae(),signOut:ut,signUpEmail:xt(),signInEmail:dt,forgetPassword:pt,resetPassword:mt,verifyEmail:st,sendVerificationEmail:it,changeEmail:At,changePassword:yt,setPassword:wt,updateUser:ht(),deleteUser:bt,forgetPasswordCallback:ft,listSessions:tt(),revokeSession:rt,revokeSessions:ot,revokeOtherSessions:nt,linkSocialAccount:Tt,listUserAccounts:Ut},...r,ok:Rt,error:kt},d={};for(let[u,s]of Object.entries(n))d[u]=async(a={})=>{let c=await e;c.session=null;for(let l of t.plugins||[])if(l.hooks?.before)for(let p of l.hooks.before){let g={...s,...a,context:{...c,...a?.context}};if(p.matcher(g)){let h=await p.handler(g);h&&"context"in h&&(a={...h,...a})}}let m;try{m=await s({...a,context:{...c,...a.context}})}catch(l){if(l instanceof ve){let p=t.plugins?.map(h=>{if(h.hooks?.after)return h.hooks.after}).filter(h=>h!==void 0).flat();if(!p?.length)throw l;let g=new Response(JSON.stringify(l.body),{status:zr[l.status],headers:l.headers}),y;for(let h of p||[]){let A={...s,...a,context:{...c,...a.context,endpoint:s,returned:g}};if(h.matcher(A)){let x=await h.handler(A);x&&"response"in x&&(y=x.response)}}if(y instanceof Response)return y;throw l}throw l}let f=m;for(let l of t.plugins||[])if(l.hooks?.after)for(let p of l.hooks.after){let g={...s,...a,context:{...c,...a.context,endpoint:s,returned:f}};if(p.matcher(g)){let h=await p.handler(g);h&&("response"in h&&(f=h.response),"responseHeader"in h&&(f instanceof Response?f=new Response(f.body,{status:f.status,headers:{...f.headers,...h.responseHeader}}):d[u].headers=h.responseHeader))}}return f},d[u].path=s.path,d[u].method=s.method,d[u].options=s.options,d[u].headers=s.headers;return{api:d,middlewares:o}}var It=(e,t)=>{let{api:r,middlewares:o}=Ue(e,t),i=new URL(e.baseURL).pathname;return jr(r,{extraContext:e,basePath:i,routerMiddleware:[{path:"/**",middleware:Se},...o],async onRequest(n){for(let d of e.options.plugins||[])if(d.onRequest){let u=await d.onRequest(n,e);if(u&&"response"in u)return u.response}return Pt(n,e)},async onResponse(n){for(let d of e.options.plugins||[])if(d.onResponse){let u=await d.onResponse(n,e);if(u)return u.response}return n},onError(n){if(n instanceof ve&&n.status==="FOUND")return;if(t.onAPIError?.throw)throw n;if(t.onAPIError?.onError){t.onAPIError.onError(n,e);return}let d=t.logger?.level,u=d==="error"||d==="warn"||d==="debug"?L:void 0;if(t.logger?.disabled!==!0){if(n&&typeof n=="object"&&"message"in n&&typeof n.message=="string"&&(n.message.includes("no column")||n.message.includes("column")||n.message.includes("relation")||n.message.includes("table")||n.message.includes("does not exist"))){e.logger?.error(n.message),e.logger?.error("If you are seeing this error, it is likely that you need to run the migrations for the database or you need to update your database schema. If you recently updated the package, make sure to run the migrations.");return}n instanceof ve?(n.status==="INTERNAL_SERVER_ERROR"&&e.logger.error(n.status,n),u?.error(n.message)):e.logger?.error(n&&typeof n=="object"&&"name"in n?n.name:"",n)}}})};import{defu as Wr}from"defu";import{decodeHex as Mr,encodeHex as Ot}from"oslo/encoding";import{scryptAsync as Hr}from"@noble/hashes/scrypt";import{getRandomValues as Gr}from"uncrypto";var G={N:16384,r:16,p:1,dkLen:64};async function St(e,t){return await Hr(e.normalize("NFKC"),t,{N:G.N,p:G.p,r:G.r,dkLen:G.dkLen,maxmem:128*G.N*G.r*2})}var _t=async e=>{let t=Ot(Gr(new Uint8Array(16))),r=await St(e,t);return`${t}:${Ot(r)}`},Lt=async(e,t)=>{let[r,o]=e.split(":"),i=await St(t,r);return me(i,Mr(o))};function Ct(e,t){let r=t.hooks;async function o(d,u,s){let a=d;for(let f of r||[]){let l=f[u]?.create?.before;if(l){let p=await l(d);if(p===!1)return null;typeof p=="object"&&"data"in p&&(a=p.data)}}let c=s?await s.fn(a):null,m=!s||s.executeMainFn?await e.create({model:u,data:a}):c;for(let f of r||[]){let l=f[u]?.create?.after;l&&await l(m)}return m}async function i(d,u,s,a){let c=d;for(let l of r||[]){let p=l[s]?.update?.before;if(p){let g=await p(d);if(g===!1)return null;c=typeof g=="object"?g.data:g}}let m=a?await a.fn(c):null,f=!a||a.executeMainFn?await e.update({model:s,update:c,where:u}):m;for(let l of r||[]){let p=l[s]?.update?.after;p&&await p(f)}return f}async function n(d,u,s,a){let c=d;for(let l of r||[]){let p=l[s]?.update?.before;if(p){let g=await p(d);if(g===!1)return null;c=typeof g=="object"?g.data:g}}let m=a?await a.fn(c):null,f=!a||a.executeMainFn?await e.updateMany({model:s,update:c,where:u}):m;for(let l of r||[]){let p=l[s]?.update?.after;p&&await p(f)}return f}return{createWithHooks:o,updateWithHooks:i,updateManyWithHooks:n}}var Te=(e,t)=>{let r=t.options,o=r.secondaryStorage,i=r.session?.expiresIn||60*60*24*7,{createWithHooks:n,updateWithHooks:d,updateManyWithHooks:u}=Ct(e,t);return{createOAuthUser:async(s,a)=>{try{let c=await n({id:B(),createdAt:new Date,updatedAt:new Date,...s},"user"),m=await n({id:B(),...a,userId:c.id||s.id},"account");return{user:c,account:m}}catch(c){return console.log(c),null}},createUser:async s=>await n({id:B(),createdAt:new Date,updatedAt:new Date,emailVerified:!1,...s},"user"),createAccount:async s=>await n({id:B(),createdAt:new Date,updatedAt:new Date,...s},"account"),listSessions:async s=>{if(o){let c=await o.get(`active-sessions-${s}`);if(!c)return[];let m=M(c)||[],f=Date.now(),l=m.filter(g=>g.expiresAt>f),p=[];for(let g of l){let y=await o.get(g.id);if(y){let h=JSON.parse(y),A=le(t.options,{...h.session,expiresAt:new Date(h.session.expiresAt)});p.push(A)}}return p}return await e.findMany({model:"session",where:[{field:"userId",value:s}]})},listUsers:async(s,a,c,m)=>await e.findMany({model:"user",limit:s,offset:a,sortBy:c,where:m}),deleteUser:async s=>{await e.deleteMany({model:"session",where:[{field:"userId",value:s}]}),await e.deleteMany({model:"account",where:[{field:"userId",value:s}]}),await e.delete({model:"user",where:[{field:"id",value:s}]})},createSession:async(s,a,c,m)=>{let f=a instanceof Request?a.headers:a,l={expiresAt:c?S(60*60*24,"sec"):S(i,"sec"),ipAddress:a&&fe(a,t.options)||"",userAgent:f?.get("user-agent")||"",...m,id:B(32),userId:s};return await n(l,"session",o?{fn:async g=>{let y=await e.findOne({model:"user",where:[{field:"id",value:s}]});o.set(g.id,JSON.stringify({session:g,user:y}),i);let h=await o.get(`active-sessions-${s}`),A=[],w=Date.now();return h&&(A=M(h)||[],A=A.filter(x=>x.expiresAt>w)),A.push({id:g.id,expiresAt:w+i*1e3}),await o.set(`active-sessions-${s}`,JSON.stringify(A),i),g},executeMainFn:r.session?.storeSessionInDatabase}:void 0)},findSession:async s=>{if(o){let f=await o.get(s);if(f){let l=JSON.parse(f),p=le(t.options,{...l.session,expiresAt:new Date(l.session.expiresAt)}),g=xe(t.options,{...l.user,createdAt:new Date(l.user.createdAt),updatedAt:new Date(l.user.updatedAt)});return{session:p,user:g}}}let a=await e.findOne({model:"session",where:[{value:s,field:"id"}]});if(!a)return null;let c=await e.findOne({model:"user",where:[{value:a.userId,field:"id"}]});if(!c)return null;let m=xe(t.options,c);return{session:le(t.options,a),user:m}},findSessions:async s=>{if(o){let f=[];for(let l of s){let p=await o.get(l);if(p){let g=JSON.parse(p),y={session:{...g.session,expiresAt:new Date(g.session.expiresAt)},user:{...g.user,createdAt:new Date(g.user.createdAt),updatedAt:new Date(g.user.updatedAt)}};f.push(y)}}return f}let a=await e.findMany({model:"session",where:[{field:"id",value:s,operator:"in"}]}),c=a.map(f=>f.userId);if(!c.length)return[];let m=await e.findMany({model:"user",where:[{field:"id",value:c,operator:"in"}]});return a.map(f=>{let l=m.find(p=>p.id===f.userId);return l?{session:f,user:l}:null})},updateSession:async(s,a)=>await d(a,[{field:"id",value:s}],"session",o?{async fn(m){let f=await o.get(s),l=null;if(f){let p=JSON.parse(f);l={...p.session,...m},await o.set(s,JSON.stringify({session:l,user:p.user}),p.session.expiresAt?Math.floor((p.session.expiresAt.getTime()-Date.now())/1e3):i)}else return null},executeMainFn:r.session?.storeSessionInDatabase}:void 0),deleteSession:async s=>{if(o){await o.delete(s),r.session?.storeSessionInDatabase&&await e.delete({model:"session",where:[{field:"id",value:s}]});return}await e.delete({model:"session",where:[{field:"id",value:s}]})},deleteSessions:async s=>{if(o){if(typeof s=="string"){let a=await o.get(`active-sessions-${s}`),c=a?M(a):[];if(!c)return;for(let m of c)await o.delete(m.id)}else for(let a of s)await o.get(a)&&await o.delete(a);r.session?.storeSessionInDatabase&&await e.deleteMany({model:"session",where:[{field:Array.isArray(s)?"id":"userId",value:s,operator:Array.isArray(s)?"in":void 0}]});return}await e.deleteMany({model:"session",where:[{field:Array.isArray(s)?"id":"userId",value:s,operator:Array.isArray(s)?"in":void 0}]})},findUserByEmail:async(s,a)=>{let c=await e.findOne({model:"user",where:[{value:s.toLowerCase(),field:"email"}]});if(!c)return null;if(a?.includeAccounts){let m=await e.findMany({model:"account",where:[{value:c.id,field:"userId"}]});return{user:c,accounts:m}}return{user:c,accounts:[]}},findUserById:async s=>await e.findOne({model:"user",where:[{field:"id",value:s}]}),linkAccount:async s=>await n({id:B(),...s},"account"),updateUser:async(s,a)=>await d(a,[{field:"id",value:s}],"user"),updateUserByEmail:async(s,a)=>await d(a,[{field:"email",value:s}],"user"),updatePassword:async(s,a)=>{await u({password:a},[{field:"userId",value:s},{field:"providerId",value:"credential"}],"account")},findAccounts:async s=>await e.findMany({model:"account",where:[{field:"userId",value:s}]}),findAccount:async s=>await e.findOne({model:"account",where:[{field:"accountId",value:s}]}),findAccountByUserId:async s=>await e.findMany({model:"account",where:[{field:"userId",value:s}]}),updateAccount:async(s,a)=>await d(a,[{field:"id",value:s}],"account"),createVerificationValue:async s=>await n({id:B(),createdAt:new Date,...s},"verification"),findVerificationValue:async s=>(await e.findMany({model:"verification",where:[{field:"identifier",value:s}],sortBy:{field:"createdAt",direction:"desc"},limit:10}))[0],deleteVerificationValue:async s=>{await e.delete({model:"verification",where:[{field:"id",value:s}]})},deleteVerificationByIdentifier:async s=>{await e.delete({model:"verification",where:[{field:"identifier",value:s}]})},updateVerificationValue:async(s,a)=>await d(a,[{field:"id",value:s}],"verification")}};var X=e=>{let t=e.plugins?.reduce((s,a)=>{let c=a.schema;if(!c)return s;for(let[m,f]of Object.entries(c))s[m]={fields:{...s[m]?.fields,...f.fields},modelName:f.modelName||m};return s},{}),r=e.rateLimit?.storage==="database",o={rateLimit:{modelName:e.rateLimit?.modelName||"rateLimit",fields:{key:{type:"string",fieldName:e.rateLimit?.fields?.key||"key"},count:{type:"number",fieldName:e.rateLimit?.fields?.count||"count"},lastRequest:{type:"number",fieldName:e.rateLimit?.fields?.lastRequest||"lastRequest"}}}},{user:i,session:n,account:d,...u}=t||{};return{user:{modelName:e.user?.modelName||"user",fields:{name:{type:"string",required:!0,fieldName:e.user?.fields?.name||"name"},email:{type:"string",unique:!0,required:!0,fieldName:e.user?.fields?.email||"email"},emailVerified:{type:"boolean",defaultValue:()=>!1,required:!0,fieldName:e.user?.fields?.emailVerified||"emailVerified"},image:{type:"string",required:!1,fieldName:e.user?.fields?.image||"image"},createdAt:{type:"date",defaultValue:()=>new Date,required:!0,fieldName:e.user?.fields?.createdAt||"createdAt"},updatedAt:{type:"date",defaultValue:()=>new Date,required:!0,fieldName:e.user?.fields?.updatedAt||"updatedAt"},...i?.fields,...e.user?.additionalFields},order:1},session:{modelName:e.session?.modelName||"session",fields:{expiresAt:{type:"date",required:!0,fieldName:e.session?.fields?.expiresAt||"expiresAt"},ipAddress:{type:"string",required:!1,fieldName:e.session?.fields?.ipAddress||"ipAddress"},userAgent:{type:"string",required:!1,fieldName:e.session?.fields?.userAgent||"userAgent"},userId:{type:"string",fieldName:e.session?.fields?.userId||"userId",references:{model:e.user?.modelName||"user",field:"id",onDelete:"cascade"},required:!0},...n?.fields,...e.session?.additionalFields},order:2},account:{modelName:e.account?.modelName||"account",fields:{accountId:{type:"string",required:!0,fieldName:e.account?.fields?.accountId||"accountId"},providerId:{type:"string",required:!0,fieldName:e.account?.fields?.providerId||"providerId"},userId:{type:"string",references:{model:e.user?.modelName||"user",field:"id",onDelete:"cascade"},required:!0,fieldName:e.account?.fields?.userId||"userId"},accessToken:{type:"string",required:!1,fieldName:e.account?.fields?.accessToken||"accessToken"},refreshToken:{type:"string",required:!1,fieldName:e.account?.fields?.refreshToken||"refreshToken"},idToken:{type:"string",required:!1,fieldName:e.account?.fields?.idToken||"idToken"},expiresAt:{type:"date",required:!1,fieldName:e.account?.fields?.expiresAt||"expiresAt"},password:{type:"string",required:!1,fieldName:e.account?.fields?.password||"password"},...d?.fields},order:3},verification:{modelName:e.verification?.modelName||"verification",fields:{identifier:{type:"string",required:!0,fieldName:e.verification?.fields?.identifier||"identifier"},value:{type:"string",required:!0,fieldName:e.verification?.fields?.value||"value"},expiresAt:{type:"date",required:!0,fieldName:e.verification?.fields?.expiresAt||"expiresAt"},createdAt:{type:"date",required:!1,defaultValue:()=>new Date,fieldName:e.verification?.fields?.createdAt||"createdAt"}},order:4},...u,...r?o:{}}};import{z as ed}from"zod";import{Kysely as Bt,MssqlDialect as Kr}from"kysely";import{MysqlDialect as Dt,PostgresDialect as Nt,SqliteDialect as qt}from"kysely";function Vt(e){if("dialect"in e)return Vt(e.dialect);if("createDriver"in e){if(e instanceof qt)return"sqlite";if(e instanceof Dt)return"mysql";if(e instanceof Nt)return"postgres";if(e instanceof Kr)return"mssql"}return"aggregate"in e?"sqlite":"getConnection"in e?"mysql":"connect"in e?"postgres":null}var Ee=async e=>{let t=e.database;if("db"in t)return{kysely:t.db,databaseType:t.type};if("dialect"in t)return{kysely:new Bt({dialect:t.dialect}),databaseType:t.type};let r,o=Vt(t);return"createDriver"in t&&(r=t),"aggregate"in t&&(r=new qt({database:t})),"getConnection"in t&&(r=new Dt(t)),"connect"in t&&(r=new Nt({pool:t})),{kysely:r?new Bt({dialect:r}):null,databaseType:o}};var Qr=(e,t,r)=>{let o=X(t);function i(a,c){if(c==="id")return c;let m=o[a].fields[c];return m||console.log("Field not found",a,c),m.fieldName||c}function n(a,c,m){let{type:f="sqlite"}=r||{},l=o[c].fields[m];return l.type==="boolean"&&f==="sqlite"?a?1:0:l.type==="date"&&a&&a instanceof Date&&f==="sqlite"?a.toISOString():a}function d(a,c,m){let{type:f="sqlite"}=r||{},l=o[c].fields[m];return l.type==="boolean"&&f==="sqlite"&&a!==null?a===1:l.type==="date"&&a?new Date(a):a}function u(a){return o[a].modelName}let s=r?.generateId!==!1;return{transformInput(a,c){let m=a.id&&s?{id:r?.generateId?r.generateId():a.id}:{};for(let f in a){let l=o[c].fields[f];l&&(m[l.fieldName||f]=n(a[f],c,f))}return m},transformOutput(a,c,m=[]){if(!a)return null;let f=a.id?m.length===0||m.includes("id")?{id:a.id}:{}:{},l=o[c].fields;for(let p in l){if(m.length&&!m.includes(p))continue;let g=l[p];g&&(f[p]=d(a[g.fieldName||p],c,p))}return f},convertWhereClause(a,c){if(!c)return{and:null,or:null};let m={and:[],or:[]};return c.forEach(f=>{let{field:l,value:p,operator:g="=",connector:y="AND"}=f,h=i(a,l),A=w=>g.toLowerCase()==="in"?w(h,"in",Array.isArray(p)?p:[p]):g==="contains"?w(h,"like",`%${p}%`):g==="starts_with"?w(h,"like",`${p}%`):g==="ends_with"?w(h,"like",`%${p}`):g==="eq"?w(h,"=",p):g==="ne"?w(h,"<>",p):g==="gt"?w(h,">",p):g==="gte"?w(h,">=",p):g==="lt"?w(h,"<",p):g==="lte"?w(h,"<=",p):w(h,g,p);y==="OR"?m.or.push(A):m.and.push(A)}),{and:m.and.length?m.and:null,or:m.or.length?m.or:null}},async withReturning(a,c,m,f){let l;if(r?.type!=="mysql")l=await c.returningAll().executeTakeFirst();else{await c.execute();let p=a.id?"id":f[0].field?f[0].field:"id",g=a[p]||f[0].value;l=await e.selectFrom(u(m)).selectAll().where(i(m,p),"=",g).executeTakeFirst()}return l},getModelName:u,getField:i}},Ft=(e,t)=>r=>{let{transformInput:o,withReturning:i,transformOutput:n,convertWhereClause:d,getModelName:u,getField:s}=Qr(e,r,t);return{id:"kysely",async create(a){let{model:c,data:m,select:f}=a,l=o(m,c),p=e.insertInto(u(c)).values(l);return n(await i(l,p,c,[]),c,f)},async findOne(a){let{model:c,where:m,select:f}=a,{and:l,or:p}=d(c,m),g=e.selectFrom(u(c)).selectAll();l&&(g=g.where(h=>h.and(l.map(A=>A(h))))),p&&(g=g.where(h=>h.or(p.map(A=>A(h)))));let y=await g.executeTakeFirst();return y?n(y,c,f):null},async findMany(a){let{model:c,where:m,limit:f,offset:l,sortBy:p}=a,{and:g,or:y}=d(c,m),h=e.selectFrom(u(c));g&&(h=h.where(w=>w.and(g.map(x=>x(w))))),y&&(h=h.where(w=>w.or(y.map(x=>x(w))))),h=h.limit(f||100),l&&(h=h.offset(l)),p&&(h=h.orderBy(s(c,p.field),p.direction));let A=await h.selectAll().execute();return A?A.map(w=>n(w,c)):[]},async update(a){let{model:c,where:m,update:f}=a,{and:l,or:p}=d(c,m),g=o(f,c),y=e.updateTable(u(c)).set(g);return l&&(y=y.where(h=>h.and(l.map(A=>A(h))))),p&&(y=y.where(h=>h.or(p.map(A=>A(h))))),n(await i(g,y,c,m),c)},async updateMany(a){let{model:c,where:m,update:f}=a,{and:l,or:p}=d(c,m),g=o(f,c),y=e.updateTable(u(c)).set(g);return l&&(y=y.where(A=>A.and(l.map(w=>w(A))))),p&&(y=y.where(A=>A.or(p.map(w=>w(A))))),(await y.execute()).length},async delete(a){let{model:c,where:m}=a,{and:f,or:l}=d(c,m),p=e.deleteFrom(u(c));f&&(p=p.where(g=>g.and(f.map(y=>y(g))))),l&&(p=p.where(g=>g.or(l.map(y=>y(g))))),await p.execute()},async deleteMany(a){let{model:c,where:m}=a,{and:f,or:l}=d(c,m),p=e.deleteFrom(u(c));return f&&(p=p.where(g=>g.and(f.map(y=>y(g))))),l&&(p=p.where(g=>g.or(l.map(y=>y(g))))),(await p.execute()).length},options:t}};async function $t(e){if(!e.database)throw new O("Database configuration is required");if(typeof e.database=="function")return e.database(e);let{kysely:t,databaseType:r}=await Ee(e);if(!t)throw new O("Failed to initialize database adapter");return Ft(t,{generateId:"generateId"in e.database?e.database.generateId:void 0,type:r||"sqlite"})(e)}var Pe="better-auth-secret-123456789";import{APIError as jt}from"better-call";async function zt(e,t){let o=(await t.context.internalAdapter.findAccounts(e))?.find(d=>d.providerId==="credential"),i=o?.password;if(!o||!i)throw new jt("BAD_REQUEST",{message:"No password credential found"});if(!await t.context.password.verify(i,t.body.password))throw new jt("BAD_REQUEST",{message:"Invalid password"});return!0}var Mt=async e=>{let t=await $t(e),r=e.plugins||[],o=Jr(e),i=ie(e.logger),n=W(e.baseURL,e.basePath),d=e.secret||_.BETTER_AUTH_SECRET||_.AUTH_SECRET||Pe;d===Pe&&Q&&i.error("You are using the default secret. Please set `BETTER_AUTH_SECRET` in your environment variables or pass `secret` in your auth config."),e={...e,secret:d,baseURL:n?new URL(n).origin:"",basePath:e.basePath||"/api/auth",plugins:r.concat(o),emailAndPassword:{...e.emailAndPassword,enabled:e.emailAndPassword?.enabled??!1,autoSignIn:e.emailAndPassword?.autoSignIn??!0}};let u=De(e),s=X(e),a=Object.keys(e.socialProviders||{}).map(f=>{let l=e.socialProviders?.[f];return l.enabled===!1?null:((!l.clientId||!l.clientSecret)&&i.warn(`Social provider ${f} is missing clientId or clientSecret`),be[f](l))}).filter(f=>f!==null),c={appName:e.appName||"Better Auth",socialProviders:a,options:e,tables:s,trustedOrigins:Yr(e),baseURL:n||"",sessionConfig:{updateAge:e.session?.updateAge||24*60*60,expiresIn:e.session?.expiresIn||60*60*24*7},secret:d,rateLimit:{...e.rateLimit,enabled:e.rateLimit?.enabled??Q,window:e.rateLimit?.window||10,max:e.rateLimit?.max||100,storage:e.rateLimit?.storage||e.secondaryStorage?"secondary-storage":"memory"},authCookies:u,logger:i,uuid:B,session:null,secondaryStorage:e.secondaryStorage,password:{hash:e.emailAndPassword?.password?.hash||_t,verify:e.emailAndPassword?.password?.verify||Lt,config:{minPasswordLength:e.emailAndPassword?.minPasswordLength||8,maxPasswordLength:e.emailAndPassword?.maxPasswordLength||128},checkPassword:zt},adapter:t,internalAdapter:Te(t,{options:e,hooks:e.databaseHooks?[e.databaseHooks]:[]}),createAuthCookie:ge(e)},{context:m}=Zr(c);return m};function Zr(e){let t=e.options,r=t.plugins||[],o=e,i=[];for(let n of r)if(n.init){let d=n.init(e);typeof d=="object"&&(d.options&&(d.options.databaseHooks&&i.push(d.options.databaseHooks),t=Wr(t,d.options)),d.context&&(o={...o,...d.context}))}return i.push(t.databaseHooks),o.internalAdapter=Te(e.adapter,{options:t,hooks:i.filter(n=>n!==void 0)}),o.options=t,{context:o}}function Jr(e){let t=[];return e.advanced?.crossSubDomainCookies?.enabled,t}function Yr(e){let t=W(e.baseURL,e.basePath);if(!t)return[];let r=[new URL(t).origin];e.trustedOrigins&&r.push(...e.trustedOrigins);let o=_.BETTER_AUTH_TRUSTED_ORIGINS;return o&&r.push(...o.split(",")),r}var ec=e=>{let t=Mt(e),{api:r}=Ue(t,e);return{handler:async o=>{let i=await t,n=i.options.basePath||"/api/auth",d=new URL(o.url);if(!i.options.baseURL){let s=W(void 0,n)||`${d.origin}${n}`;i.options.baseURL=s,i.baseURL=s}if(i.trustedOrigins.push(d.origin),!i.options.baseURL)return new Response("Base URL not set",{status:400});if(d.pathname===n||d.pathname===`${n}/`)return new Response("Welcome to BetterAuth",{status:200});let{handler:u}=It(i,e);return u(o)},api:r,options:e,$context:t,$Infer:{}}};export{O as BetterAuthError,z as HIDE_METADATA,Le as MissingDependencyError,ec as betterAuth,Tn as capitalizeFirstLetter,ge as createCookieGetter,ie as createLogger,q as deleteSessionCookie,B as generateId,ne as generateState,De as getCookies,ye as levels,L as logger,Ro as parseCookies,mo as parseSetCookieHeader,$e as parseState,I as setSessionCookie,gr as shouldPublishLog};
