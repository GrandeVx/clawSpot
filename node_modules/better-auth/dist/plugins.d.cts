export { A as AnonymousOptions, J as JwtOptions, O as OrganizationOptions, b as Passkey, P as PasskeyOptions, e as UserWithAnonymous, U as UserWithPhoneNumber, h as UserWithRole, i as admin, f as anonymous, n as emailOTP, j as genericOAuth, g as getPasskeyActions, k as jwt, m as magicLink, l as multiSession, o as organization, p as passkey, c as passkeyClient, d as phoneNumber, t as twoFactor, a as twoFactorClient, u as username } from './index-Q5mYsB6F.cjs';
import { H as HookEndpointContext } from './auth-DvJrys4P.cjs';
export { M as AuthEndpoint, N as AuthMiddleware, j as BetterAuthPlugin, k as InferOptionSchema, P as PluginSchema, J as createAuthEndpoint, F as createAuthMiddleware, D as optionsMiddleware } from './auth-DvJrys4P.cjs';
export { H as HIDE_METADATA } from './hide-metadata-DEHJp1rk.cjs';
import * as better_call from 'better-call';
import { z } from 'zod';
import './helper-DrEEwdyQ.cjs';
import './plugins/access.cjs';
import '@better-fetch/fetch';
import 'nanostores';
import '@simplewebauthn/types';
import './index-BNVrpPYq.cjs';
import 'jose';
import 'kysely';
import 'better-sqlite3';

/**
 * Converts bearer token to session cookie
 */
declare const bearer: () => {
    id: "bearer";
    hooks: {
        before: {
            matcher(context: HookEndpointContext): boolean;
            handler: (c: HookEndpointContext) => Promise<{
                context: HookEndpointContext;
            } | undefined>;
        }[];
    };
};

interface OneTapOptions {
    /**
     * Disable the signup flow
     *
     * @default false
     */
    disableSignup?: boolean;
}
declare const oneTap: (options?: OneTapOptions) => {
    id: "one-tap";
    endpoints: {
        oneTapCallback: {
            <C extends [better_call.Context<"/one-tap/callback", {
                method: "POST";
                body: z.ZodObject<{
                    idToken: z.ZodString;
                }, "strip", z.ZodTypeAny, {
                    idToken: string;
                }, {
                    idToken: string;
                }>;
            }>]>(...ctx: C): Promise<C extends [{
                asResponse: true;
            }] ? Response : {
                error: string;
            } | {
                session: {
                    id: string;
                    userId: string;
                    expiresAt: Date;
                    ipAddress?: string | null | undefined;
                    userAgent?: string | null | undefined;
                };
                user: {
                    user: any;
                    account: any;
                };
            } | {
                session: {
                    id: string;
                    userId: string;
                    expiresAt: Date;
                    ipAddress?: string | null | undefined;
                    userAgent?: string | null | undefined;
                };
                user: {
                    user: {
                        id: string;
                        email: string;
                        emailVerified: boolean;
                        name: string;
                        createdAt: Date;
                        updatedAt: Date;
                        image?: string | null | undefined;
                    };
                    accounts: {
                        id: string;
                        providerId: string;
                        accountId: string;
                        userId: string;
                        accessToken?: string | null | undefined;
                        refreshToken?: string | null | undefined;
                        idToken?: string | null | undefined;
                        expiresAt?: Date | null | undefined;
                        password?: string | null | undefined;
                    }[];
                };
            }>;
            path: "/one-tap/callback";
            options: {
                method: "POST";
                body: z.ZodObject<{
                    idToken: z.ZodString;
                }, "strip", z.ZodTypeAny, {
                    idToken: string;
                }, {
                    idToken: string;
                }>;
            };
            method: better_call.Method | better_call.Method[];
            headers: Headers;
        };
    };
};

interface OAuthProxyOptions {
    /**
     * The current URL of the application.
     * The plugin will attempt to infer the current URL from your environment
     * by checking the base URL from popular hosting providers,
     * from the request URL if invoked by a client,
     * or as a fallback, from the `baseURL` in your auth config.
     * If the URL is not inferred correctly, you can provide a value here."
     */
    currentURL?: string;
}
/**
 * A proxy plugin, that allows you to proxy OAuth requests.
 * Useful for development and preview deployments where
 * the redirect URL can't be known in advance to add to the OAuth provider.
 */
declare const oAuthProxy: (opts?: OAuthProxyOptions) => {
    id: "oauth-proxy";
    endpoints: {
        oAuthProxy: {
            <C extends [better_call.Context<"/oauth-proxy-callback", {
                method: "GET";
                query: z.ZodObject<{
                    callbackURL: z.ZodString;
                    cookies: z.ZodString;
                }, "strip", z.ZodTypeAny, {
                    callbackURL: string;
                    cookies: string;
                }, {
                    callbackURL: string;
                    cookies: string;
                }>;
            }>]>(...ctx: C): Promise<C extends [{
                asResponse: true;
            }] ? Response : never>;
            path: "/oauth-proxy-callback";
            options: {
                method: "GET";
                query: z.ZodObject<{
                    callbackURL: z.ZodString;
                    cookies: z.ZodString;
                }, "strip", z.ZodTypeAny, {
                    callbackURL: string;
                    cookies: string;
                }, {
                    callbackURL: string;
                    cookies: string;
                }>;
            };
            method: better_call.Method | better_call.Method[];
            headers: Headers;
        };
    };
    hooks: {
        after: {
            matcher(context: HookEndpointContext<{
                returned: unknown;
                endpoint: better_call.Endpoint;
            }>): boolean;
            handler: better_call.Endpoint<better_call.Handler<string, better_call.EndpointOptions, {
                response: Response;
            } | undefined>, better_call.EndpointOptions>;
        }[];
        before: {
            matcher(context: HookEndpointContext): boolean;
            handler(ctx: HookEndpointContext): Promise<{
                context: HookEndpointContext;
            }>;
        }[];
    };
};

export { bearer, oAuthProxy, oneTap };
